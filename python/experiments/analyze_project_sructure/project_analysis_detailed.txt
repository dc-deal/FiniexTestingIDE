================================================================================
FINIEXTESTINGIDE - PROJECT STRUCTURE ANALYSIS
================================================================================

ğŸ“Š STATISTICS OVERVIEW
--------------------------------------------------------------------------------
Total Files Analyzed:        148
Total Directories:           27
Total Classes:               212
Total Methods:               825
Avg Methods per Class:       3.9

Documentation Coverage:
  Classes:                   210/212 (99.1%)
  Methods:                   764/825 (92.6%)

Classes with Inheritance:    65/212
Namespace Conflicts:         2

Top 5 Largest Classes (by method count):
  1. PortfolioManager                24 methods  (framework/trading_env/portfolio_manager.py)
  2. TradeSimulator                  24 methods  (framework/trading_env/trade_simulator.py)
  3. AppConfigManager                23 methods  (configuration/app_config_manager.py)
  4. BrokerConfig                    23 methods  (framework/trading_env/broker_config.py)
  5. AbstractLogger                  20 methods  (components/logger/abstract_logger.py)


================================================================================
DETAILED CLASS ANALYSIS
================================================================================

================================================================================
class BarIndexCLI
  File: cli/bar_index_cli.py:24

  Class Docstring:
    Command-line interface for bar index management and reporting.

  Methods (6):

    ğŸ”’ __init__()
       Docstring:
         Initialize CLI

    ğŸ”“ cmd_rebuild()
       Docstring:
         Rebuild bar index from scratch

    ğŸ”“ cmd_status()
       Docstring:
         Show bar index status and overview

    ğŸ”“ cmd_report()
       Docstring:
         Generate detailed bar index report and save to framework/reports

    ğŸ”“ cmd_render()
       Docstring:
         Render bars from tick data

    ğŸ”“ cmd_help()
       Docstring:
         Show help

================================================================================
class DataIndexCLI
  File: cli/data_index_cli.py:30

  Class Docstring:
    Command-line interface for Parquet index management and data import.

  Methods (10):

    ğŸ”’ __init__()
       Docstring:
         Initialize CLI

    ğŸ”“ cmd_import()
       Docstring:
         Import tick data from JSON to Parquet with UTC conversion.
         
         Args:
             override: If True, overwrite existing Parquet files
             time_offset: Manual UTC offset in hours (e.g., -3 for GMT+3 â†’ UTC)

    ğŸ”“ cmd_rebuild()
       Docstring:
         Rebuild index from scratch

    ğŸ”“ cmd_status()
       Docstring:
         Show index status

    ğŸ”“ cmd_tick_data_report()
       Docstring:
         Tick data report

    ğŸ”“ cmd_coverage()
       Docstring:
         Show coverage statistics for symbol

    ğŸ”“ cmd_gaps()
       Docstring:
         Analyze and report gaps for symbol

    ğŸ”“ cmd_files()
       Docstring:
         Show files selected for time range

    ğŸ”“ cmd_validate()
       Docstring:
         Validate all symbols and show gaps

    ğŸ”“ cmd_help()
       Docstring:
         Show help

================================================================================
class ScenarioCLI
  File: cli/scenario_cli.py:35

  Class Docstring:
    CLI handler for scenario analysis and generation.

  Methods (5):

    ğŸ”’ __init__()
       Docstring:
         Initialize CLI handler.
         
         Args:
             data_dir: Path to processed data directory

    ğŸ”“ cmd_analyze()
       Docstring:
         Analyze market data and print report with cross-instrument comparison.
         
         Args:
             symbols: List of symbols to analyze
             timeframe: Timeframe override

    ğŸ”“ cmd_generate()
       Docstring:
         Generate scenario configurations.
         
         Args:
             symbols: List of symbols
             strategy: Generation strategy (balanced, blocks, stress)
             count: Number of scenarios
             block_size: Block size in hours (for blocks strategy)
             session: Single session filter
             sessions: Comma-separated session filters
             start: Start date filter (ISO format)
             end: End date filter (ISO format)
             output: Output filename
             max_ticks: Max ticks per scenario

    ğŸ”’ _generate_output_name()
       Docstring:
         Generate output filename from symbols and strategy.
         
         Args:
             symbols: List of symbols
             strategy: Generation strategy
         
         Returns:
             Filename string

    ğŸ”’ _print_generation_summary()
       Docstring:
         Print generation result summary.
         
         Args:
             result: GenerationResult
             config_path: Path to saved config

================================================================================
class LiveProgressDisplay
  File: components/display/live_progress_display.py:43

  Class Docstring:
    Live progress display for scenario execution.
    
    Queue-based design for ProcessPool compatibility.
    Reads updates from multiprocessing.Queue and renders display.
    
    Shows:
    - System resources (CPU, RAM)
    - Number of running/completed scenarios
    - Per-scenario progress bars with stats
    - Real-time updates every 300ms

  Methods (11):

    ğŸ”’ __init__()
       Docstring:
         Initialize live progress display.
         
         Args:
             scenarios: List of scenarios to track
             live_queue: Queue for receiving live updates
             update_interval: Update interval in seconds (default: 0.3)

    ğŸ”’ _init_stats_cache()
       Docstring:
         Initialize stats cache with INITIALIZED status.

    ğŸ”“ start()
       Docstring:
         Start the live display thread.

    ğŸ”“ stop()
       Docstring:
         Stop the live display thread.

    ğŸ”’ _update_loop()
       Docstring:
         Main update loop running in thread.

    ğŸ”’ _process_update()
       Docstring:
         Process a single queue update and update cache.
         
         Args:
             update: Update message from queue

    ğŸ”’ _render()
       Docstring:
         Render the live display.
         
         Returns:
             Rich Panel with overhead + scenario progress

    ğŸ”’ _build_overhead()
       Docstring:
         Build overhead resource line.
         
         Args:
             all_stats: List of LiveScenarioStats objects
         
         Returns:
             Formatted string with system resources

    ğŸ”’ _build_scenario_table()
       Docstring:
         Build scenario progress table.
         
         Args:
             all_stats: List of LiveScenarioStats objects
         
         Returns:
             Rich Table with scenario progress bars

    ğŸ”’ _get_status_display()
       Docstring:
         Get icon and color for a scenario status.
         
         Args:
             status: ScenarioStatus enum value
         
         Returns:
             Tuple of (icon, name_color)

    ğŸ”’ _build_progress_text()
       Docstring:
         Build progress bar and text based on scenario status.
         
         Args:
             stats: LiveScenarioStats object
         
         Returns:
             Formatted progress string

================================================================================
class AbstractLogger
  Inherits from: ABC
  File: components/logger/abstract_logger.py:27

  Class Docstring:
    Abstract base class for all loggers.
    
    Provides common functionality:
    - Log level validation
    - Filtering based on log levels
    - Error methods with auto-flush and exit
    - Color-coded console output
    
    Subclasses implement:
    - _log(level, message) - Different buffering/output strategies
    - _get_timestamp() - Different timestamp formats

  Methods (20):

    ğŸ”’ __init__()
       Docstring:
         Initialize abstract logger.
         
         Args:
             name: Logger name/identifier

    ğŸ”’ _log_console_implementation()
       Docstring:
         Core logging method - must be implemented by subclasses.
         
         Different implementations:
         - GlobalLogger: Direct console + file output
         - ScenarioLogger: Buffered console + direct file output
         
         Args:
             level: Log level (INFO, DEBUG, WARNING, ERROR)
             message: Log message

    ğŸ”’ _write_to_file_implementation()
       Docstring:
         Write to global log file.
         
         Args:
             level: Log level
             message: Log message (plain text, no colors)
             timestamp: DateTime timestamp

    ğŸ”’ _get_timestamp()
       Docstring:
         Get timestamp string for log entry.
         
         Different implementations:
         - GlobalLogger: DateTime string (e.g., "2025-10-22 14:30:45")
         - ScenarioLogger: Elapsed time (e.g., "[ 3s 417ms]")
         
         Returns:
             Formatted timestamp string

    ğŸ”’ _should_log_console()
       Docstring:
         check if console log is enabled for logger

    ğŸ”’ _should_log_file()
       Docstring:
         check if file log is enabled for logger

    ğŸ”“ verbose()
       Docstring:
         Log VERBOSE message - All Logs also Tick / Order Data

    ğŸ”“ debug()
       Docstring:
         Log DEBUG message Many Logs - also minor log events

    ğŸ”“ info()
       Docstring:
         Log INFO message (respects log level filtering)

    ğŸ”“ warning()
       Docstring:
         Log WARNING message (respects log level filtering)

    ğŸ”“ error()
       Docstring:
         Log ERROR message (respects log level filtering)

    ğŸ”“ validation_error()
       Docstring:
         Parameter/Input validation error.
         
         Use for: Invalid user input, wrong parameter values, constraint violations.
         NO stack trace (error message should be self-explanatory).
         
         Args:
             message: Human-readable error description
             context: Optional dict with error context
         
         Behavior:
             - Flushes all buffered logs
             - Prints formatted error message
             - Exits with code 1

    ğŸ”“ config_error()
       Docstring:
         Configuration file error.
         
         Use for: Missing config files, invalid JSON, schema violations.
         NO stack trace.
         
         Args:
             message: Human-readable error description
             file_path: Optional path to problematic config file
         
         Behavior:
             - Flushes all buffered logs
             - Prints formatted error message
             - Exits with code 1

    ğŸ”“ hard_error()
       Docstring:
         Critical code error (WITH stack trace).
         
         Use for: Unexpected exceptions, runtime errors, bugs.
         Shows full stack trace for debugging.
         
         Args:
             message: Human-readable error description
             exception: Optional exception object
         
         Behavior:
             - Flushes all buffered logs
             - Prints formatted error message with stack trace
             - Exits with code 1

    ğŸ”“ get_buffer()
       Docstring:
         Return a serializable copy of the console buffer.
         
         This makes it safe to pass across processes (e.g. via ProcessPoolExecutor).

    ğŸ”“ set_buffer()
       Docstring:
         Replace the current console buffer with a provided list.

    ğŸ”“ print_buffer()
       Docstring:
         Print a buffer that was obtained via get_buffer().
         
         Can be used in the parent process after collecting logs from workers.

    ğŸ”’ _get_color_for_level()
       Docstring:
         Get ANSI color code for log level

    ğŸ”’ _process_log()
       âš ï¸  NO DOCSTRING

    ğŸ”’ _format_log_line()
       Docstring:
         Format a log line with color and timestamp.
         
         Args:
             level: Log level
             message: Log message
             timestamp: Timestamp string (format depends on subclass)
         
         Returns:
             Formatted log line

================================================================================
class FileLogger
  File: components/logger/file_logger.py:28

  Class Docstring:
    File logger for a single log file (global or scenario-specific).
    
    File structure:
        logs/scenario_sets/eurusd_3_windows/20251021_105359/
            global.log                           (all global logs + summary)
            config.json                          (config snapshot)
            scenario_0_GBPUSD_window_02.log     (scenario 0 logs)
            scenario_1_GBPUSD_window_03.log     (scenario 1 logs)

  Methods (7):

    ğŸ”’ __init__()
       Docstring:
         Initialize file logger.
         
         Args:
             run_dir: Directory for log files
             scenario_name: Scenario name (for scenario logs)
             log_level: Minimum log level to write

    ğŸ”’ _write_header()
       Docstring:
         Write log file header

    ğŸ”’ _write_append_separator()
       Docstring:
         Write separator when appending to existing log

    ğŸ”“ set_tick_loop_started()
       âš ï¸  NO DOCSTRING

    ğŸ”“ set_current_tick()
       âš ï¸  NO DOCSTRING

    ğŸ”“ write_log()
       Docstring:
         Write log entry to file.
         
         Used by both GlobalLogger and ScenarioLogger.
         - GlobalLogger: timestamp is DateTime string
         - ScenarioLogger: timestamp is elapsed time string
         
         Args:
             level: Log level (INFO, DEBUG, WARNING, ERROR)
             message: Plain text message (no colors)
             timestamp: Pre-formatted timestamp string

    ğŸ”“ close()
       Docstring:
         Close file handle.
         
         CRITICAL: Must be called to prevent ProcessPool shutdown delays!
         Open file handles prevent process termination - Python waits ~11s for timeout.

================================================================================
class GlobalLogger
  Inherits from: AbstractLogger
  File: components/logger/global_logger.py:24

  Class Docstring:
    Global logger for application-level logs.
    
    Features:
    - DateTime timestamps (e.g., "2025-10-22 14:30:45")
    - Direct console output (no buffering)
    - Direct file output via FileLogger
    - Singleton pattern

  Methods (7):

    ğŸ”’ __init__()
       Docstring:
         Initialize global logger.
         
         Args:
             name: Logger name (default: "FiniexTestingIDE")

    ğŸ”“ print_log_info()
       Docstring:
         Print where logs are being written (or if disabled)

    ğŸ”’ _get_timestamp()
       Docstring:
         Get DateTime timestamp.
         
         Returns:
             DateTime string (e.g., "2025-10-22 14:30:45")

    ğŸ”’ _should_log_console()
       Docstring:
         check if console log is enabled for logger

    ğŸ”’ _should_log_file()
       Docstring:
         check if file log is enabled for logger

    ğŸ”’ _log_console_implementation()
       Docstring:
           Format Message for Global Log
         Args:
             level: Log level (INFO, DEBUG, WARNING, ERROR)
             message: Log message

    ğŸ”’ _write_to_file_implementation()
       Docstring:
         Write to global log file.
         
         Args:
             level: Log level
             message: Log message (plain text, no colors)
             timestamp: DateTime timestamp

================================================================================
class ScenarioLogger
  Inherits from: AbstractLogger
  File: components/logger/scenario_logger.py:28

  Class Docstring:
    Scenario-specific logger with buffered console output.
    
    Features:
    - Elapsed time timestamps (e.g., "[ 3s 417ms]")
    - Console buffering (prevents chaos during parallel execution)
    - Direct file output (one file per scenario)
    - Automatic flush on errors

  Methods (16):

    ğŸ”’ __init__()
       Docstring:
         Initialize scenario logger.
         
         Args:
             scenario_set_name: Scenario set name
             scenario_name: Scenario name (e.g., "GBPUSD_window_01")
             run_timestamp: Run timestamp string

    ğŸ”’ _get_timestamp()
       Docstring:
         Get elapsed time since scenario start.
         
         Returns:
             Elapsed time string (e.g., "[ 3s 417ms]")

    ğŸ”’ _should_log_console()
       Docstring:
         check if console log is enabled for logger

    ğŸ”’ _should_log_file()
       Docstring:
         check if file log is enabled for logger

    ğŸ”“ should_logLevel()
       Docstring:
         check if any log is active - usecase: scenario silent mode (only file log)

    ğŸ”“ get_run_timestamp()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_log_dir()
       âš ï¸  NO DOCSTRING

    ğŸ”“ reset_start_time()
       âš ï¸  NO DOCSTRING

    ğŸ”“ set_tick_loop_started()
       âš ï¸  NO DOCSTRING

    ğŸ”“ set_current_tick()
       âš ï¸  NO DOCSTRING

    ğŸ”’ _log_console_implementation()
       Docstring:
             Format Message for Scenario Log.
         
         Console: Buffered (flush at end)
         File: Direct write (no buffer)
         
         Args:
             level: Log level (INFO, DEBUG, WARNING, ERROR)
             message: Log message

    ğŸ”’ _add_to_console_buffer()
       Docstring:
         Add log line to console buffer.
         
         Args:
             level: Log level
             formatted_line: Pre-formatted log line with colors

    ğŸ”’ _write_to_file_implementation()
       Docstring:
         Write directly to scenario log file.
         
         Args:
             level: Log level
             message: Log message (plain text, no colors)
             timestamp: Elapsed time timestamp

    ğŸ”“ flush_buffer()
       Docstring:
         Flush console buffer to stdout.
         
         Called at end of scenario execution or on errors.
         Outputs all buffered logs in order.

    ğŸ”“ close()
       Docstring:
         Close logger and flush any remaining buffers.
         
         Call at end of scenario execution.

    ğŸ”“ get_elapsed_time_seconds()
       Docstring:
         Get elapsed time since scenario start in seconds.
         
         Returns:
             Elapsed time in seconds

================================================================================
class AppConfigManager
  File: configuration/app_config_manager.py:13

  Class Docstring:
    Centralized application configuration loader.
    
    Loads and provides access to app_config.json settings.
    Singleton pattern ensures config is loaded only once.

  Methods (23):

    ğŸ”’ __init__()
       Docstring:
         Initialize app config loader.

    ğŸ”’ _print_config_status()
       Docstring:
         Print config status (replaces old config.py print)

    ğŸ”“ get_console_logging_config_object()
       Docstring:
         Get structured logging configuration.

    ğŸ”“ get_file_logging_config_object()
       Docstring:
         Get structured file logging configuration.
             ValueError: If config structure invalid

    ğŸ”“ get_config()
       Docstring:
         Get full configuration.
         
         Returns:
             Complete config dict

    ğŸ”“ get_execution_config()
       Docstring:
         Get execution configuration.
         
         Returns:
             Execution config dict

    ğŸ”“ get_logging_show_scenario_logging()
       Docstring:
         Check if scenario logging should be shown in console.
         
         Returns:
             True if scenario logs should be displayed

    ğŸ”“ get_logging_write_system_info()
       Docstring:
         Check if system info should be written for scenarios.
         
         Returns:
             True if system info should be written

    ğŸ”“ get_paths_config()
       Docstring:
         Get paths configuration.
         
         Returns:
             Paths config dict

    ğŸ”“ get_monitoring_config()
       Docstring:
         Get monitoring configuration.
         
         Returns:
             Monitoring config dict

    ğŸ”“ get_default_parallel_scenarios()
       Docstring:
         Get default parallel scenarios setting.
         
         Returns:
             True if scenarios should run in parallel by default

    ğŸ”“ get_default_max_parallel_scenarios()
       Docstring:
         Get default max parallel scenarios.
         
         Returns:
             Max number of scenarios to run in parallel

    ğŸ”“ get_default_parallel_workers()
       Docstring:
         Get default parallel workers setting.
         
         Returns:
             True if workers should run in parallel by default

    ğŸ”“ should_warn_on_override()
       Docstring:
         Check if parameter override warnings are enabled.
         
         Returns:
             True if warnings should be shown

    ğŸ”“ get_console_log_level()
       Docstring:
         Get console log level (validated).
         
         UPDATED: Now uses LoggingConfig with inheritance.
         
         Returns:
             Validated log level string (DEBUG, INFO, WARNING, ERROR)

    ğŸ”“ get_development_config()
       Docstring:
         Get development configuration.
         
         Returns:
             Development config dict

    ğŸ”“ get_importer_config()
       Docstring:
         Get importer configuration.
         
         Returns:
             Importer config dict

    ğŸ”“ get_dev_mode()
       Docstring:
         Get dev mode setting.
         
         Returns:
             True if dev mode is enabled

    ğŸ”“ get_move_processed_files()
       Docstring:
         Get move processed files setting.
         
         Returns:
             True if processed files should be moved

    ğŸ”“ get_delete_on_error()
       Docstring:
         Get delete on error setting.
         
         Returns:
             True if files should be deleted on error

    ğŸ”“ get_data_validation_config()
       Docstring:
         Get data validation configuration.
         
         Returns:
             Data validation config dict

    ğŸ”“ get_warmup_quality_mode()
       Docstring:
         Get warmup quality mode.
         
         Returns:
             Warmup quality mode: 'permissive' or 'standard' (default: 'standard')

    ğŸ”“ get_allowed_gap_categories()
       Docstring:
         Get allowed gap categories for validation.
         
         Returns:
             List of allowed gap category strings (default: ['seamless', 'short'])

================================================================================
class ConfigFileLoader
  File: configuration/config_file_loader.py:6

  âš ï¸  NO CLASS DOCSTRING

  Methods (4):

    ğŸ”“ initialize()
       Docstring:
         Init the loader with a path (only once).

    ğŸ”“ get_config()
       Docstring:
         Returns the configuration and whether it was loaded during this call.
         
         Loads the config once and caches it. The boolean indicates if the config
         was freshly loaded (`True`) or returned from cache (`False`).
         
         Returns:
             Tuple[Dict[str, Any], bool]: (config_dict, was_first_load)

    ğŸ”“ reload()
       Docstring:
         Force reload of config.

    ğŸ”’ _load()
       Docstring:
         Internal load logic â€” uses your existing load_config.

================================================================================
class ConsoleLoggingConfig
  File: configuration/console_logging_config.py:15

  Class Docstring:
    Logging configuration with inheritance support.
    
    Handles console logging and scenario-specific overrides.
    Supports null inheritance pattern for enabled and log_level.

  Methods (10):

    ğŸ”’ __init__()
       Docstring:
         Initialize logging config with inheritance logic.
         
         Args:
             config_dict: Raw logging config from app_config.json
         
         Raises:
             ValueError: If required fields missing or invalid

    ğŸ”’ _validate_scenario_config()
       Docstring:
         Validate scenario config structure.
         
         Args:
             scenario_config: Scenario config dict
         
         Raises:
             ValueError: If required fields missing

    ğŸ”“ console_enabled()
       Docstring:
         Console logging enabled

    ğŸ”“ global_log_level()
       Docstring:
         Console log level (validated)

    ğŸ”“ warn_on_parameter_override()
       Docstring:
         Warn when scenario overrides parameters

    ğŸ”“ scenario_enabled()
       Docstring:
         Scenario logging enabled (after inheritance)

    ğŸ”“ scenario_log_level()
       Docstring:
         Scenario log level (after inheritance)

    ğŸ”“ scenario_write_system_info()
       Docstring:
         Write system info for scenarios

    ğŸ”“ should_log_scenarios()
       Docstring:
         Check if scenario logs should be displayed.
         
         This replaces the old show_scenario_logging flag.
         
         Returns:
             True if scenarios should log to console

    ğŸ”’ __repr__()
       Docstring:
         Debug representation

================================================================================
class FileLoggingConfig
  File: configuration/file_logging_config.py:16

  Class Docstring:
    File logging configuration with global/scenario separation.
    
    Handles:
    - Global log: Single file with append mode
    - Scenario logs: Per-run directories with overwrite

  Methods (11):

    ğŸ”’ __init__()
       Docstring:
         Initialize file logging config.
         
         Args:
             config_dict: Raw file_logging config from app_config.json
         
         Raises:
             ValueError: If required fields missing or invalid

    ğŸ”’ _validate_scenario_config()
       Docstring:
         Validate scenario config structure.
         
         Args:
             scenario_config: Scenario config dict
         
         Raises:
             ValueError: If required fields missing

    ğŸ”“ global_enabled()
       Docstring:
         Global file logging enabled

    ğŸ”“ global_log_level()
       Docstring:
         Global log level (validated)

    ğŸ”“ global_log_path()
       Docstring:
         Path to global.log file

    ğŸ”“ global_append_mode()
       Docstring:
         Append to global.log (vs overwrite)

    ğŸ”“ scenario_enabled()
       Docstring:
         Scenario file logging enabled (after inheritance)

    ğŸ”“ scenario_log_level()
       Docstring:
         Scenario log level (after inheritance)

    ğŸ”“ scenario_log_root_path()
       Docstring:
         Root directory for scenario logs

    ğŸ”“ is_file_logging_enabled()
       Docstring:
         Check if any file logging is enabled.
         
         Returns:
             True if global OR scenario file logging active

    ğŸ”’ __repr__()
       Docstring:
         Debug representation

================================================================================
class BarsIndexManager
  File: data_worker/data_loader/bars_index_manager.py:25

  Class Docstring:
    Manages index for pre-rendered bar parquet files.
    
    Structure mirrors tick index but for bars:
    - Scans mt5/bars/**/*.parquet
    - Builds .parquet_bars_index.json
    - Enables fast bar file selection

  Methods (12):

    ğŸ”’ __init__()
       Docstring:
         Initialize bar index manager.
         
         Args:
             data_dir: Root data directory (e.g., ./data/processed/)

    ğŸ”’ _version_less_than()
       Docstring:
         Compare version strings (e.g., '1.0.5' < '1.1.0').
         
         Args:
             version: Version to check
             compare_to: Version to compare against
         
         Returns:
             True if version < compare_to

    ğŸ”“ build_index()
       Docstring:
         Build or load index from bar parquet files.
         
         Scans: */bars/**/*.parquet
         
         Args:
             force_rebuild: Always rebuild, ignore existing index

    ğŸ”’ _scan_bar_file()
       Docstring:
         Scan single bar parquet file and extract metadata.
         
         Extended to include tick statistics and bar type distribution
         for market analysis and scenario generation.
         
         Args:
             bar_file: Path to bar parquet file
         
         Returns:
             Index entry dict with metadata and aggregated statistics

    ğŸ”“ needs_rebuild()
       Docstring:
         Check if index needs rebuilding.
         
         Triggers:
         - Index file doesn't exist
         - Index is older than newest bar file
         
         Returns:
             True if rebuild needed

    ğŸ”“ get_bar_file()
       Docstring:
         Get bar file path for symbol/timeframe.
         
         THIS IS THE CORE FUNCTION!
         Returns the single bar file for warmup or backtesting.
         
         Args:
             symbol: Trading symbol (e.g., 'EURUSD')
             timeframe: Timeframe (e.g., 'M5')
         
         Returns:
             Path to bar file or None if not found
         
         Example:
             >>> index = BarsIndexManager(data_dir)
             >>> bar_file = index.get_bar_file('EURUSD', 'M5')
             >>> bars = pd.read_parquet(bar_file)  # Load M5 bars instantly!

    ğŸ”“ get_available_timeframes()
       Docstring:
         Get list of available timeframes for a symbol.
         
         Args:
             symbol: Trading symbol
         
         Returns:
             List of available timeframes (e.g., ['M1', 'M5', 'M15'])

    ğŸ”“ save_index()
       Docstring:
         Save index to JSON file

    ğŸ”“ load_index()
       Docstring:
         Load index from JSON file

    ğŸ”“ list_symbols()
       Docstring:
         List all available symbols in bar index.
         
         Returns:
             Sorted list of symbol names

    ğŸ”“ get_symbol_stats()
       Docstring:
         Get statistics for a symbol.
         
         Args:
             symbol: Trading symbol
         
         Returns:
             Dict with statistics per timeframe

    ğŸ”“ print_summary()
       Docstring:
         Print bar index summary

================================================================================
class TickDataLoader
  File: data_worker/data_loader/data_loader_core.py:28

  Class Docstring:
    Core tick data loading with caching and filtering.

  Methods (6):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ list_available_symbols()
       Docstring:
         List all available symbols [UNCHANGED - uses index]

    ğŸ”“ load_symbol_data()
       Docstring:
         Load tick data for a symbol with optional date filtering.
         Index handles new structure transparently]

    ğŸ”’ _get_symbol_files()
       Docstring:
         Get all Parquet files for a symbol (legacy method).
         
         CHANGED: Neue Glob-Pattern fÃ¼r Collector-First Hierarchie

    ğŸ”’ _check_artificial_duplicates()
       Docstring:
         Check for artificial duplicates via Parquet metadata 

    ğŸ”’ _apply_date_filters()
       Docstring:
         Apply date range filters to DataFrame 

================================================================================
class DuplicateReport
  Decorators: dataclass
  File: data_worker/data_loader/data_loader_exceptions.py:16

  Class Docstring:
    Detailed report about detected artificial duplicates
    
    Contains comparison metrics and recommendations for dealing
    with duplicate Parquet files from the same source.
    
    Attributes:
        source_file: Name of the original JSON source file
        duplicate_files: List of Parquet files with same source
        tick_counts: Number of ticks in each file
        time_ranges: Time range (start, end) for each file
        file_sizes_mb: File sizes in MB for each file
        metadata: List of dicts with Parquet metadata for each file

  Methods (4):

    ğŸ”“ get_detailed_report()
       Docstring:
         Generate detailed text report with metadata comparison
         
         Returns:
             Formatted report string with analysis and recommendations

    ğŸ”’ _tick_counts_identical()
       Docstring:
         Check if all tick counts are identical

    ğŸ”’ _time_ranges_identical()
       Docstring:
         Check if all time ranges are identical

    ğŸ”’ _are_metadata_identical()
       Docstring:
         Check if all metadata is identical (except processed_at and data_collector)
         
         processed_at is excluded because it changes on re-import
         data_collector is excluded because cross-collector duplicates are still duplicates

================================================================================
class DataQualityException
  Inherits from: Exception
  File: data_worker/data_loader/data_loader_exceptions.py:207

  Class Docstring:
    Base exception for all data quality issues

================================================================================
class ArtificialDuplicateException
  Inherits from: DataQualityException
  File: data_worker/data_loader/data_loader_exceptions.py:212

  Class Docstring:
    Raised when artificial duplicates are detected in Parquet files
    
    Artificial duplicates occur when:
    - Same source JSON is imported multiple times (should overwrite, not duplicate)
    - Parquet files are manually copied in processed/ directory
    - Same data imported under different data_collectors (NEW in C#003b)
    - File system issues cause duplication
    
    This exception includes a detailed DuplicateReport for analysis.
    
    Attributes:
        report: DuplicateReport instance with detailed information

  Methods (1):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

================================================================================
class InvalidDataModeException
  Inherits from: DataQualityException
  File: data_worker/data_loader/data_loader_exceptions.py:233

  Class Docstring:
    Raised when an invalid data_mode is specified
    
    Valid data_modes are:
    - "raw": Keep all duplicates (maximum realism)
    - "realistic": Remove duplicates (normal testing)
    - "clean": Remove duplicates (clean testing)

  Methods (1):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

================================================================================
class TickDataAnalyzer
  File: data_worker/data_loader/tick_data_analyzer.py:22

  Class Docstring:
    Provides analysis and statistics for tick data

  Methods (5):

    ğŸ”’ __init__()
       Docstring:
         Initialize analyzer with a data loader

    ğŸ”“ get_symbol_info()
       Docstring:
         Get comprehensive information about a symbol
         
         Returns dict with: symbol, files, total_ticks, date_range,
         statistics, file_size_mb, sessions

    ğŸ”“ get_data_summary()
       Docstring:
         Create overview of all available data

    ğŸ”“ get_available_date_range()
       Docstring:
         Get available date range for a symbol (fast metadata-only check)

    ğŸ”’ _count_weekends()
       Docstring:
         Count weekends between two dates.
         
           Now uses MarketCalendar.get_weekend_statistics()
         for consistency across codebase.
         
         Args:
             start_date: Start timestamp
             end_date: End timestamp
         
         Returns:
             Dict with weekend statistics (same format as before)

================================================================================
class TickDataReporter
  File: data_worker/data_loader/tick_data_report.py:20

  Class Docstring:
    Generates formatted reports and summaries for tick data

  Methods (4):

    ğŸ”’ __init__()
       Docstring:
         Initialize reporter with loader and analyzer

    ğŸ”“ print_symbol_info()
       Docstring:
         vLog.info formatted symbol information to console

    ğŸ”“ print_all_symbols()
       Docstring:
         vLog.info summary for all available symbols

    ğŸ”“ test_load_symbol()
       Docstring:
         Test loading data for a symbol and display sample

================================================================================
class TickIndexManager
  File: data_worker/data_loader/tick_index_manager.py:24

  Class Docstring:
    Manages Parquet file index for fast time-based file selection.

  Methods (12):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ build_index()
       Docstring:
         Build or load index from Parquet files.

    ğŸ”’ _scan_file()
       Docstring:
         Scan single Parquet file and extract metadata.
         [UNCHANGED - works with any path structure]

    ğŸ”“ needs_rebuild()
       Docstring:
         Check if index needs rebuilding.

    ğŸ”“ get_relevant_files()
       Docstring:
         Find ONLY files covering requested time range 

    ğŸ”“ save_index()
       Docstring:
         Save index to JSON file 

    ğŸ”“ load_index()
       Docstring:
         Load index from JSON file 

    ğŸ”“ get_coverage_report()
       Docstring:
         Generate coverage report for a symbol 

    ğŸ”“ get_symbol_coverage()
       Docstring:
         Get basic coverage statistics for a symbol 

    ğŸ”“ list_symbols()
       Docstring:
         List all available symbols 

    ğŸ”“ print_summary()
       Docstring:
         Print index summary 

    ğŸ”“ print_coverage_report()
       Docstring:
         Print coverage report for a symbol 

================================================================================
class BarImporter
  File: data_worker/importer/bar_importer.py:36

  Class Docstring:
    Main orchestrator for bar pre-rendering system.
    
    Renders bars from tick data and saves them as parquet files.
    One file per timeframe per symbol.

  Methods (8):

    ğŸ”’ __init__()
       Docstring:
         Initialize Bar Importer.
         
         Args:
             data_dir: Root data directory (default: ./data/parquet/)

    ğŸ”“ render_bars_for_all_symbols()
       Docstring:
         Render bars for ALL symbols found in tick data.
         
         Use this after bulk tick import to pre-render everything.
         
         Args:
             data_collector: Data collector name (default: 'mt5')
             clean_mode: If True, delete all existing bars before rendering (default: False)

    ğŸ”“ render_bars_for_symbol()
       Docstring:
         Render bars for a single symbol.
         
         Steps:
         1. Load ALL tick files for symbol
         2. Render bars for all timeframes
         3. Write bar parquet files
         4. Log statistics
         
         Args:
             symbol: Trading symbol (e.g., 'EURUSD')
             data_collector: Data collector name (default: 'mt5')

    ğŸ”’ _load_all_ticks_for_symbol()
       Docstring:
         Load ALL tick files for a symbol.
         
         Unlike TickDataLoader which can filter by date,
         we load everything for complete bar rendering.
         
         Args:
             symbol: Trading symbol
             data_collector: Data collector name
         
         Returns:
             DataFrame with all ticks for symbol

    ğŸ”’ _write_bar_file()
       Docstring:
         Write bar DataFrame to parquet file.
         
         File structure: data_collector/bars/symbol/SYMBOL_TF_BARS.parquet
         Example: mt5/bars/EURUSD/EURUSD_M5_BARS.parquet
         
         Args:
             symbol: Trading symbol
             timeframe: Timeframe string
             bars_df: Bar DataFrame
             data_collector: Data collector name

    ğŸ”’ _extract_source_versions()
       Docstring:
         Extract min/max data_format_version from tick parquet files.
         
         Args:
             tick_files: List of tick parquet file paths
         
         Returns:
             Tuple (version_min, version_max)

    ğŸ”’ _update_bar_index()
       Docstring:
         Update bar index after rendering.
         
         Creates/updates .parquet_bars_index.json

    ğŸ”’ _print_summary()
       Docstring:
         Print processing summary

================================================================================
class TickDataImporter
  File: data_worker/importer/tick_importer.py:38

  Class Docstring:
    Konvertiert MQL5 JSON-Exports zu Parquet-Format mit UTC-Konvertierung.
    
    Hauptfunktionen:
    - JSON â†’ Parquet Konvertierung (10:1 Kompression)
    - Datentyp-Optimierung fÃ¼r Performance
    - UTC Timezone Conversion mit manuellem Offset
    - Session-Neuberechnung basierend auf UTC
    - QualitÃ¤ts-Checks und Bereinigung
    - Batch-Verarbeitung mit Error-Handling
    - Duplicate Prevention mit Override-Option
    - Hierarchical directory structure
    - Market type detection (v1.4+)
    
    Args:
        source_dir (str): Verzeichnis mit JSON-Files
        target_dir (str): Zielverzeichnis fÃ¼r Parquet-Output
        override (bool): Wenn True, Ã¼berschreibe existierende Files
        time_offset (int): Manueller UTC-Offset in Stunden (z.B. -3 fÃ¼r GMT+3)

  Methods (12):

    ğŸ”’ __init__()
       Docstring:
         Initialisiert Importer mit Source- und Target-Pfaden.
         
         Args:
             source_dir (str): MQL5 JSON-Export-Verzeichnis
             target_dir (str): Parquet-Zielverzeichnis
             override (bool): Ãœberschreibe existierende Dateien
             time_offset (int): UTC-Offset in Stunden

    ğŸ”“ process_all_mql5_exports()
       Docstring:
         Sucht alle TickCollector-Exports und konvertiert sie sequenziell.
         Fehler stoppen nicht die Verarbeitung weiterer Files.

    ğŸ”“ rebuild_parquet_index()
       Docstring:
         Rebuild index after successful imports

    ğŸ”“ convert_json_to_parquet()
       Docstring:
         Konvertiert einzelne JSON-Datei zu optimiertem Parquet mit UTC-Konvertierung.
         
         Pipeline:
         1. JSON laden und Struktur validieren
         2. DataFrame erstellen und Datentypen optimieren
         3. Time Offset anwenden (wenn gesetzt)
         4. Sessions neu berechnen (wenn Offset angewendet)
         5. QualitÃ¤ts-Checks
         6. Check for existing duplicates (mit Override-Support)
         7. Als Parquet mit Metadaten speichern

    ğŸ”’ _determine_market_type()
       Docstring:
         Bestimmt den Markttyp basierend auf Metadata und Version.
         
         Logik:
         - Version < 1.1.0: Implizit forex_cfd (alle alten MT5-Daten)
         - Version >= 1.1.0: Explizit aus metadata['market_type']
         
         Args:
             metadata: JSON-Metadata aus der Quelldatei
             data_format_version: Datenformat-Version
         
         Returns:
             market_type string: 'forex_cfd', 'crypto_spot', etc.

    ğŸ”’ _apply_time_offset()
       Docstring:
         Wendet manuellen Time-Offset auf Timestamps an.
         
         Args:
             df: DataFrame mit 'timestamp' Spalte
         
         Returns:
             DataFrame mit angepassten Timestamps

    ğŸ”’ _recalculate_sessions()
       Docstring:
         Berechnet Trading-Sessions neu basierend auf UTC-Zeit.

    ğŸ”’ _check_for_existing_duplicate()
       Docstring:
         Check if Parquet file already exists with same source.
         
         Mit Override-Support: Gibt Duplicate-Report zurÃ¼ck, aber
         lÃ¶scht NICHT automatisch (das macht der Caller).

    ğŸ”’ _optimize_datatypes()
       Docstring:
         Optimiert DataFrame-Datentypen fÃ¼r Performance.

    ğŸ”’ _quality_checks()
       Docstring:
         FÃ¼hrt QualitÃ¤ts-Checks auf Tick-Daten durch.

    ğŸ”’ _print_summary()
       Docstring:
         Gibt Zusammenfassung der Batch-Verarbeitung aus.

    ğŸ”’ _trigger_bar_rendering()
       Docstring:
         Trigger automatic bar rendering after tick import.
         
         Renders bars for all symbols that were just imported.

================================================================================
class VectorizedBarRenderer
  File: data_worker/importer/vectorized_bar_renderer.py:26

  Class Docstring:
    Fast vectorized bar rendering for batch processing.
    
    Uses pandas.resample() instead of tick-by-tick loops.
    Perfect for pre-rendering bars from tick data.

  Methods (6):

    ğŸ”’ __init__()
       Docstring:
         Initialize renderer for a specific symbol.
         
         Args:
             symbol: Trading symbol (e.g., 'EURUSD')

    ğŸ”“ render_all_timeframes()
       Docstring:
         Render bars for all supported timeframes from tick data.
         
         This is the main entry point - renders all 7 timeframes in one go!
         
         Args:
             ticks_df: DataFrame with tick data (must have 'timestamp', 'bid', 'ask')
             fill_gaps: Insert synthetic bars for gaps (default: True)
         
         Returns:
             Dict[timeframe, DataFrame] - Bars for each timeframe
         
         Example:
             >>> renderer = VectorizedBarRenderer('EURUSD')
             >>> bars = renderer.render_all_timeframes(ticks_df)
             >>> m5_bars = bars['M5']  # Get M5 bars

    ğŸ”’ _prepare_ticks_for_resampling()
       Docstring:
         Prepare tick DataFrame for pandas resample().
         
         Steps:
         1. Calculate mid-price from bid/ask
         2. Ensure timestamp is datetime (critical!)
         3. Set timestamp as index
         4. Sort chronologically
         
         Args:
             ticks_df: Raw tick DataFrame
         
         Returns:
             Prepared DataFrame ready for resample()

    ğŸ”’ _render_single_timeframe()
       Docstring:
         Render bars for a single timeframe using pandas resample().
         
         THIS IS THE CORE MAGIC! ğŸ”®
         
         Instead of looping through 10,000 ticks individually,
         we let pandas do it in one vectorized operation.
         
         Args:
             prepared_df: Tick DataFrame (with mid-price, indexed by timestamp)
             timeframe: Timeframe to render (e.g., 'M5')
             fill_gaps: Insert synthetic bars for gaps
         
         Returns:
             DataFrame with rendered bars

    ğŸ”’ _fill_gaps()
       Docstring:
         Fill time gaps with synthetic bars.
         
         Gaps occur during:
         - Weekends (Fr 21:00 â†’ Mo 00:00)
         - Broker downtime
         - Data collection interruptions
         
         Strategy:
         - Create complete time series (no gaps)
         - For missing periods: insert synthetic bar with OHLC = last_close
         - Mark as 'synthetic' with appropriate metadata
         
         Args:
             bars_df: Real bars from ticks
             timeframe: Timeframe string
         
         Returns:
             DataFrame with gaps filled

    ğŸ”’ _find_gap_ranges()
       Docstring:
         Find consecutive gap ranges for logging.
         
         Args:
             bars_df: Bar DataFrame
             gap_mask: Boolean mask of gap rows
         
         Returns:
             List of (start_time, end_time, gap_size) tuples

================================================================================
class ClassInfo
  File: experiments/analyze_project_sructure/analyze_project_structure.py:37

  Class Docstring:
    Information Ã¼ber eine Python-Klasse.

  Methods (1):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

================================================================================
class ProjectAnalyzer
  File: experiments/analyze_project_sructure/analyze_project_structure.py:51

  Class Docstring:
    Analysiert Python-Projekt-Struktur.

  Methods (4):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ analyze()
       Docstring:
         Analysiert das gesamte Projekt.

    ğŸ”’ _analyze_file()
       Docstring:
         Analysiert eine einzelne Python-Datei.

    ğŸ”’ _generate_report()
       Docstring:
         Generiert Analyse-Report.

================================================================================
class LogWriter
  File: experiments/gil_benchmark/threading_vs_multiprocessing.py:32

  Class Docstring:
    Schreibt Output sowohl in Console als auch in Log-File.
    Erstellt automatisch intelligente Filenamen.

  Methods (4):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ start_logging()
       Docstring:
         Startet Logging in File mit intelligentem Namen.
         
         Format: gil_benchmark_<platform>_<mode>_<date>.log
         Beispiel: gil_benchmark_windows_native_20250118-1430.log

    ğŸ”“ write()
       Docstring:
         Schreibt Message zu Console und File

    ğŸ”“ close()
       Docstring:
         SchlieÃŸt Log-File

================================================================================
class BenchmarkResult
  Decorators: dataclass
  File: experiments/gil_benchmark/threading_vs_multiprocessing.py:91

  Class Docstring:
    Einzelnes Benchmark-Ergebnis - kompakt fÃ¼r Ã¼bersichtliches Logging

================================================================================
class EnvironmentDetector
  File: experiments/gil_benchmark/threading_vs_multiprocessing.py:101

  Class Docstring:
    Erkennt und loggt die komplette AusfÃ¼hrungsumgebung

  Methods (3):

    ğŸ”“ detect_execution_context()
       Docstring:
         Erkennt wie das Script aufgerufen wurde

    ğŸ”“ get_system_info()
       Docstring:
         Sammelt detaillierte System-Informationen

    ğŸ”“ print_environment_report()
       Docstring:
         Gibt kompakten Environment-Report aus

================================================================================
class RealisticScenarioSimulator
  File: experiments/gil_benchmark/threading_vs_multiprocessing.py:169

  Class Docstring:
    Simuliert ein realistisches FiniexTestingIDE Scenario

  Methods (2):

    ğŸ”“ simulate_scenario()
       Docstring:
         Simuliert komplettes Scenario mit mehreren Workers

    ğŸ”’ _simulate_worker()
       Docstring:
         Simuliert einen Worker mit RSI-Ã¤hnlichen Berechnungen

================================================================================
class ExtendedGILBenchmark
  File: experiments/gil_benchmark/threading_vs_multiprocessing.py:226

  Class Docstring:
    Erweiterter GIL Benchmark mit realistischen Szenarien

  Methods (6):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ run_test_suite()
       Docstring:
         FÃ¼hrt komplette Test-Suite durch

    ğŸ”’ _run_sequential()
       Docstring:
         Sequential execution

    ğŸ”’ _run_threading()
       Docstring:
         Threading execution

    ğŸ”’ _run_multiprocessing()
       Docstring:
         Multiprocessing execution

    ğŸ”“ print_final_summary()
       Docstring:
         Finale kompakte Zusammenfassung

================================================================================
class BarRenderer
  File: framework/bars/bar_renderer.py:20

  Class Docstring:
    Core bar renderer for all timeframes

  Methods (8):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_required_timeframes()
       Docstring:
         Collect all required timeframes from workers

    ğŸ”“ update_current_bars()
       Docstring:
         Update bars for all timeframes with new tick.
         
         PERFORMANCE OPTIMIZED:
         - tick_data.timestamp is already datetime (no parsing needed)
         - Direct datetime comparison (no pd.to_datetime)
         - Cached bar_start_time calculation (in TimeframeConfig)
         
         Returns:
             Tuple of:
             - Dict[timeframe, Bar]: Updated current bars
             - Dict[timeframe, bool]: Which bars were closed this tick

    ğŸ”’ _archive_completed_bar()
       Docstring:
         Archive completed bar to history

    ğŸ”“ get_bar_history()
       Docstring:
         Get historical bars.
         
         PERFORMANCE NOTE:
         This converts the internal deque to a list. To optimize performance,
         the BarRenderingController caches the result and only calls this
         when a bar closes, reducing calls from 2000+ to ~10-20 per test.
         
         Returns:
             List[Bar]: Historical bars

    ğŸ”“ get_current_bar()
       Docstring:
         Get current bar for symbol/timeframe

    ğŸ”“ initialize_historical_bars()
       Docstring:
         Initialize the completed_bars history with warmup bars.
         
         This method populates the historical bar storage with pre-rendered
         warmup bars, making them available for get_bar_history() calls.
         
         Args:
             symbol: The trading symbol (e.g., "EURUSD")
             timeframe: The timeframe (e.g., "M5")
             bars: List of completed warmup bars to initialize with

    ğŸ”“ render_bars_from_ticks()
       Docstring:
         Render a list of bars from a sequence of ticks.
         
         PERFORMANCE OPTIMIZED:
         - tick.timestamp is already datetime (no parsing)
         
         Args:
             ticks: List of TickData objects to process
             symbol: The trading symbol
             timeframe: The timeframe to render (e.g., "M5")
         
         Returns:
             List of completed Bar objects

================================================================================
class BarRenderingController
  File: framework/bars/bar_rendering_controller.py:21

  Class Docstring:
    Main orchestrator for bar rendering system.
    
    Manages:
    - Bar rendering via BarRenderer
    - Warmup bar injection
    - Bar history caching for performance
    - Worker registration and requirements

  Methods (8):

    ğŸ”’ __init__()
       Docstring:
         Initialize bar rendering controller.
         
         Args:
             logger: ScenarioLogger for this scenario

    ğŸ”“ register_workers()
       Docstring:
         Register workers and analyze their bar requirements.
         
         Workers specify which timeframes they need (e.g., RSI needs M5).
         This determines which bars need to be rendered.
         
         Args:
             workers: List of worker instances

    ğŸ”“ process_tick()
       Docstring:
         Process tick and update all current bars.
         
         OPTIMIZED: Returns info about which bars were closed to enable caching.
         
         Args:
             tick_data: Current tick to process
         
         Returns:
             Dict[timeframe, Bar] - Updated current bars

    ğŸ”“ get_bar_history()
       Docstring:
         Get bar history (completed bars) for specific timeframe.
         
         Args:
             symbol: Trading symbol
             timeframe: Timeframe (e.g., "M5")
         
         Returns:
             List of completed Bar objects

    ğŸ”“ get_current_bar()
       Docstring:
         Get current (incomplete) bar for specific timeframe.
         
         Args:
             symbol: Trading symbol
             timeframe: Timeframe (e.g., "M5")
         
         Returns:
             Current Bar object or None if no bar yet

    ğŸ”“ get_warmup_quality_metrics()
       Docstring:
         Get quality metrics for warmup bars.
         
         Quality metrics include counts of synthetic/real bars.
         Used for debugging and validation.
         
         Returns:
             Dict[timeframe, quality_stats] with bar type breakdowns

    ğŸ”“ get_all_bar_history()
       Docstring:
         Get all loaded warmup bars per timeframe.
         
         PERFORMANCE OPTIMIZED:
         This method caches the bar history dict and only rebuilds when
         a bar is closed. This eliminates thousands of unnecessary dict rebuilds
         and list copies during the tick loop.
         
         Cache invalidation happens in process_tick() when a bar closes.
         Expected speedup: 100-200x for this operation (from 2000 to ~10-20 rebuilds).
         
         Args:
             symbol: Trading symbol
         
         Returns:
             Dict[timeframe, List[Bar]] - All historical bars per timeframe
         
         Note:
             Returns cached references. Workers must not modify the history.

    ğŸ”“ inject_warmup_bars()
       Docstring:
         Inject prepared warmup bars WITHOUT validation.
         
         REPLACES: prepare_warmup_from_parquet_bars() in ProcessPool mode.
         
         Three critical operations:
         1. Store warmup_bars in _warmup_data (for get_all_bar_history())
         2. Convert bar dicts to Bar objects (via deserialize_bars_batch)
         3. Initialize bar_renderer history (fills completed_bars deque)
         
         NO VALIDATION: Trusts SharedDataPreparator's pre-filtering.
         
         Args:
             symbol: Trading symbol from config.symbol (authoritative)
             warmup_bars: {timeframe: tuple_of_bar_dicts}
         
         Example:
             warmup_bars = {'M5': (...), 'M30': (...)}
             controller.inject_warmup_bars('EURUSD', warmup_bars)

================================================================================
class BatchOrchestrator
  File: framework/batch/batch_orchestrator.py:137

  Class Docstring:
    Universal orchestrator for batch strategy testing.
    Handles 1 to 1000+ scenarios with same code path.
    
    Key improvement: Failed preparations don't block execution
    - Only successfully prepared scenarios wait at barrier
    - Failed scenarios are logged but don't stop batch

  Methods (3):

    ğŸ”’ __init__()
       Docstring:
         Initialize batch orchestrator.
         
         Creates run_timestamp for shared logger initialization.
         
         Args:
             scenario_set: Set of scenarios to execute
             app_config_manager: Application configuration manager

    ğŸ”“ run()
       Docstring:
         Execute all scenarios with coordinated phases.
         
         WORKFLOW:
         Phase 0: Requirements Collection (Serial)
         Phase 1: Data Preparation (Serial)
         Phase 2: Scenario Execution (Parallel/Sequential)
         
         Returns:
             BatchExecutionSummary with aggregated results from all scenarios

    ğŸ”“ flush_all_logs()
       Docstring:
         Logger flush. Run does not decide whether to console log.
         
         Args:
             batch_execution_summary: Summary with scenario results

================================================================================
class BatchReportCoordinator
  File: framework/batch/batch_report_coordinator.py:17

  Class Docstring:
    Coordinates batch execution report generation and logging.
    
    Responsibilities:
    - Create BatchSummary instance
    - Capture stdout with ANSI colors for console
    - Strip colors for file logging
    - Log to scenario set logger
    
    Note: Actual report rendering logic is in framework/reporting/batch_summary.py

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize batch report coordinator.
         
         Args:
             batch_execution_summary: Execution results to report
             scenario_set: Scenario set with logger
             app_config: Application configuration

    ğŸ”“ generate_and_log()
       Docstring:
         Generate report, print to console, and log to file.
         
         Workflow:
         1. Create BatchSummary instance
         2. Capture rendered output with ANSI colors
         3. Print colored version to console
         4. Strip colors and log to scenario file

================================================================================
class CoverageReportManager
  File: framework/batch/coverage_report_manager.py:26

  Class Docstring:
    Manages coverage report generation for batch validation.
    
    Generates gap analysis reports for all symbols in a batch run.
    Reports are used by ScenarioDataValidator to validate data quality.

  Methods (3):

    ğŸ”’ __init__()
       Docstring:
         Initialize coverage report manager.
         
         Args:
             data_dir: Root data directory (e.g., 'data/parquet')
             logger: Logger instance

    ğŸ”“ generate_reports()
       Docstring:
         Generate coverage reports for all symbols.
         
         Args:
             symbols: Set of unique symbol names
         
         Returns:
             Dict mapping symbol to CoverageReport

    ğŸ”“ validate_after_load()
       Docstring:
         Validate scenarios after data has been loaded.
         
         Phase 1.5: Quality validation with loaded data.
         
         Args:
             scenarios: List of scenarios to validate
             shared_data: Loaded tick and bar data
             requirements_map: Requirements map for warmup info
         
         Returns:
             Tuple of (valid_scenarios, invalid_scenarios_with_results)

================================================================================
class StatusBroadcaster
  Inherits from: Protocol
  File: framework/batch/data_preparation_coordinator.py:22

  Class Docstring:
    Protocol for status broadcasting (e.g., LiveStatsCoordinator)

  Methods (1):

    ğŸ”“ broadcast_status()
       âš ï¸  NO DOCSTRING

================================================================================
class DataPreparationCoordinator
  File: framework/batch/data_preparation_coordinator.py:28

  Class Docstring:
    Coordinates all data preparation for batch execution.
    
    Responsibilities:
    - Load tick data with status broadcasting
    - Load bar data with status broadcasting
    - Prepare broker configurations
    - Package all data into ProcessDataPackage

  Methods (4):

    ğŸ”’ __init__()
       Docstring:
         Initialize data preparation coordinator.
         
         Args:
             scenarios: List of scenarios for broker config preparation
             logger: Logger instance for status messages

    ğŸ”“ get_tick_index_manager()
       âš ï¸  NO DOCSTRING

    ğŸ”“ prepare()
       Docstring:
         Prepare all shared data (ticks, bars, broker configs).
         
         Args:
             requirements_map: Aggregated requirements from all scenarios
             status_broadcaster: Optional status broadcaster for live updates
         
         Returns:
             ProcessDataPackage with all prepared data

    ğŸ”“ get_broker_scenario_map()
       Docstring:
         Get broker-to-scenario mapping.
         
         Returns:
             Broker scenario map from broker preparator

================================================================================
class ExecutionCoordinator
  File: framework/batch/execution_coordinator.py:32

  Class Docstring:
    Coordinates scenario execution (sequential or parallel).
    
    Responsibilities:
    - Execute scenarios sequentially or in parallel
    - Auto-detect debugger and switch execution mode
    - Handle ProcessPoolExecutor vs ThreadPoolExecutor
    - Collect and return execution results

  Methods (4):

    ğŸ”’ __init__()
       Docstring:
         Initialize execution coordinator.
         
         Args:
             scenario_set_name: Name of the scenario set
             run_timestamp: Timestamp for this batch run
             app_config: Application configuration manager
             live_stats_config: Live stats configuration
             logger: Logger instance for status messages

    ğŸ”“ execute_sequential()
       Docstring:
         Execute scenarios sequentially.
         
         Args:
             scenarios: List of scenarios to execute
             shared_data: Prepared shared data package
             live_queue: Optional queue for live updates
         
         Returns:
             List of ProcessResult objects

    ğŸ”“ execute_parallel()
       Docstring:
         Execute scenarios in parallel with auto-detection.
         
         Automatically switches between ProcessPoolExecutor and ThreadPoolExecutor
         based on debugger detection.
         
         Args:
             scenarios: List of scenarios to execute
             shared_data: Prepared shared data package
             live_queue: Optional queue for live updates
         
         Returns:
             List of ProcessResult objects

    ğŸ”’ _create_validation_failed_result()
       Docstring:
         Create ProcessResult for validation-failed scenario.
         
         Args:
             scenario: Scenario that failed validation
             scenario_index: Index in scenario list
         
         Returns:
             ProcessResult with validation error details

================================================================================
class LiveStatsCoordinator
  File: framework/batch/live_stats_coordinator.py:14

  Class Docstring:
    Manages live statistics cache and status broadcasting.
    
    Responsibilities:
    - Initialize live stats cache for all scenarios
    - Broadcast status updates to live queue
    - Maintain scenario status state

  Methods (3):

    ğŸ”’ __init__()
       Docstring:
         Initialize live stats coordinator.
         
         Args:
             scenarios: List of scenarios to track
             live_queue: Multiprocessing queue for live updates (None if disabled)
             enabled: Whether live stats are enabled

    ğŸ”’ _init_live_stats()
       Docstring:
         Initialize LiveScenarioStats cache for all scenarios.

    ğŸ”“ broadcast_status()
       Docstring:
         Broadcast status update for all scenarios.
         
         Args:
             status: New status for all scenarios

================================================================================
class RequirementsCollector
  File: framework/batch/requirements_collector.py:15

  Class Docstring:
    Collects and aggregates data requirements from multiple scenarios.
    
    Responsibilities:
    - Iterate through all scenarios
    - Collect warmup requirements per scenario
    - Aggregate requirements into unified map
    - Return finalized requirements for data preparation

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize requirements collector.
         
         Args:
             logger: Logger instance for status messages

    ğŸ”“ collect()
       Docstring:
         Collect requirements from all scenarios.
         
         Args:
             scenarios: List of scenarios to analyze
             app_config: Application configuration manager
         
         Returns:
             Tuple of (requirements_map, warmup_requirements_by_scenario)

================================================================================
class AggregateScenarioDataRequirements
  File: framework/data_preperation/aggregate_scenario_data_requirements.py:33

  Class Docstring:
    Aggregates data requirements from all scenarios.
    
    WORKFLOW:
    1. add_scenario() for each scenario
    2. finalize() to deduplicate and optimize
    3. Output: RequirementsMap for SharedDataPreparator
    
    UTC-FIX:
    - All datetime objects are UTC-aware
    - Prevents timezone comparison errors

  Methods (3):

    ğŸ”’ __init__()
       Docstring:
         Initialize empty requirements collector.

    ğŸ”“ add_scenario()
       Docstring:
         Add requirements from one scenario.
         
         UTC-FIX: Parsed datetimes are made UTC-aware.
         
         Args:
             scenario: Scenario configuration
             scenario_index: Scenario index
         
         Returns:
             warmup_requirements: {timeframe: warmup_count} for this scenario

    ğŸ”“ finalize()
       Docstring:
         Finalize requirements with deduplication.
         
         OPTIMIZATION:
         - Merges overlapping tick ranges
         - Groups bar requirements by (symbol, timeframe, start_time)
         - Returns optimized loading strategy
         
         Returns:
             Deduplicated RequirementsMap

================================================================================
class BrokerDataPreparator
  File: framework/data_preperation/broker_data_preperator.py:23

  Class Docstring:
    Prepares broker configurations for batch execution.
    
    Performance:
    - Caches broker configs by config_path to avoid duplicate JSON loading
    - Example: 5 scenarios with same path = only 1x file I/O
    
    Usage:
        preparator = BrokerDataPreparator(scenarios, logger)
        broker_configs = preparator.prepare()
        shared_data.broker_configs = broker_configs

  Methods (6):

    ğŸ”’ __init__()
       Docstring:
         Initialize preparator.
         
         Args:
             scenarios: List of scenarios to process
             logger: Logger for broker overview output

    ğŸ”“ get_broker_scenario_map()
       âš ï¸  NO DOCSTRING

    ğŸ”“ prepare()
       Docstring:
         Main entry point - loads, maps, and logs broker configurations.
         
         Side effects:
         - Assigns broker_type to each scenario
         - Logs broker overview to logger
         
         Returns:
             Serialized broker configs ready for subprocess sharing

    ğŸ”’ _load_and_map_broker_configs()
       Docstring:
         Load unique broker configs and build scenario mapping.
         
         Performance optimization:
         - Uses config_path cache to avoid duplicate loading
         - Each unique path is loaded only once via BrokerConfigFactory
         
         Side effects:
         - Populates self._config_path_cache
         - Populates self._broker_scenario_map
         - Assigns scenario.broker_type for each scenario

    ğŸ”’ _serialize_broker_configs()
       Docstring:
         Serialize broker configs for subprocess sharing.
         
         Returns raw JSON dicts - CoW-safe and pickleable.
         Subprocesses can re-hydrate adapters from these dicts.
         
         Returns:
             Dict mapping broker_type to serialized config dict

    ğŸ”’ _log_broker_overview()
       Docstring:
         Log concise broker overview with scenario assignments.
         
         Output format:
         - Header with unique broker count
         - Per broker: single-line info + config path + scenario list

================================================================================
class SharedDataPreparator
  File: framework/data_preperation/shared_data_preparator.py:27

  Class Docstring:
    Prepares shared data for all scenarios.
    
    WORKFLOW:
    1. Load tick/bar indices (via managers)
    2. Process RequirementsMap
    3. Load data from parquet files
    4. Filter and package data
    5. Return ProcessDataPackage
    
    COW OPTIMIZATION:
    - All data stored as tuples (immutable)
    - Subprocesses share memory (0 copy!)
    - Only writes trigger memory copy
    
    UTC-FIX:
    - All timestamp comparisons are UTC-aware
    - Prevents pandas datetime comparison errors

  Methods (5):

    ğŸ”’ __init__()
       Docstring:
         Initialize data preparator with index managers.
         
         Args:
             data_dir: Root data directory containing parquet files and indices

    ğŸ”“ prepare_ticks()
       Docstring:
         Prepare tick data for all requirements.
         
         Args:
             requirements: List of tick requirements
         
         Returns:
             (ticks_data, tick_counts, tick_ranges)

    ğŸ”’ _load_ticks_tick_mode()
       Docstring:
         Load ticks in tick-limited mode.
         
         UTC-FIX: Ensures all timestamp comparisons are UTC-aware.
         
         Args:
             symbol: Symbol to load
             start_time: Start time (UTC-aware)
             max_ticks: Maximum ticks to load
         
         Returns:
             (ticks, count, time_range)

    ğŸ”’ _load_ticks_timespan_mode()
       Docstring:
         Load ticks in timespan mode.
         
         UTC-FIX: Ensures all timestamp comparisons are UTC-aware.
         
         Args:
             symbol: Symbol to load
             start_time: Start time (UTC-aware)
             end_time: End time (UTC-aware)
         
         Returns:
             (ticks, count, time_range)

    ğŸ”“ prepare_bars()
       Docstring:
         Prepare bar data for all requirements.
         
         UTC-FIX: Ensures timestamp comparisons are UTC-aware.
         
         Args:
             requirements: List of bar requirements
         
         Returns:
             (bars_data, bar_counts)

================================================================================
class AbstractDecisionLogic
  Inherits from: ABC
  File: framework/decision_logic/abstract_decision_logic.py:34

  Class Docstring:
    Abstract base class for decision logic implementations.
    
    Decision Logic takes worker results, generates trading decisions,
    and executes them via DecisionTradingAPI.
    
    Philosophy (from Worker Manifest):
    - Workers are atomic units (first level)
    - DecisionLogic orchestrates results (second level)
    - No sub-workers, no hidden dependencies
    
    Architecture:
    1. get_required_order_types() declares needed order types
    2. BatchOrchestrator validates against broker capabilities
    3. DecisionTradingAPI is injected after validation
    4. compute() generates decisions
    5. execute_decision() executes trades (Template Method)
       - Calls _execute_decision_impl() (subclass implements this)
       - Automatically updates statistics

  Methods (11):

    ğŸ”’ __init__()
       Docstring:
         Initialize decision logic.
         
         Args:
             name: Decision logic name
             logger: ScenarioLogger instance (REQUIRED)
             config: Logic-specific configuration
         
         Raises:
             ValueError: If logger is None

    ğŸ”“ get_required_order_types()
       Docstring:
         Declare which order types this logic will use.
         
         This is called BEFORE scenario starts to validate broker support.
         Prevents runtime failures from unsupported order types.
         
         Returns:
             List of OrderType that this logic needs
         
         Example:
             def get_required_order_types(self):
                 return [OrderType.MARKET, OrderType.LIMIT]

    ğŸ”“ execute_decision()
       Docstring:
         Execute trading decision via DecisionTradingAPI (Template Method).
         
         This is a template method that:
         1. Calls _execute_decision_impl() (implemented by subclass)
         2. Automatically updates statistics
         3. Returns order result
         
         Subclasses should implement _execute_decision_impl() instead.
         
         Args:
             decision: Decision object from compute()
             tick: Current tick data
         
         Returns:
             OrderResult if order was sent, None if no trade

    ğŸ”’ _execute_decision_impl()
       Docstring:
         Implementation of decision execution (to be overridden by subclass).
         
         This is called by execute_decision() template method.
         Subclass implements the actual trading logic here.
         
         Args:
             decision: Decision object from compute()
             tick: Current tick data
         
         Returns:
             OrderResult if order was sent, None if no trade

    ğŸ”“ get_required_worker_instances()
       Docstring:
         Define required worker instances with exact names and types.
         
         This is the connection between DecisionLogic and configuration.
         The config MUST provide worker_instances with matching keys and types.
         
         Example:
             {
                 "rsi_fast": "CORE/rsi",
                 "envelope_main": "CORE/envelope"
             }
         
         Config must match exactly:
             "worker_instances": {
                 "rsi_fast": "CORE/rsi",        # âœ… Same key, same type
                 "envelope_main": "CORE/envelope"  # âœ… Same key, same type
             }
         
         Type override is NOT allowed - if DecisionLogic declares
         "rsi_fast": "CORE/rsi", config cannot use "CORE/macd" instead.
         
         Returns:
             Dict[instance_name, worker_type] - The exact worker instances

    ğŸ”“ compute()
       Docstring:
         Generate trading decision based on worker results.
         
         This is the core decision-making method. It receives all worker
         outputs and must return a structured Decision object.
         
         Args:
             tick: Current tick data
             worker_results: Dict[worker_name, WorkerResult] - All worker outputs
             current_bars: Current bars per timeframe
             bar_history: Historical bars per timeframe
         
         Returns:
             Decision object with action/confidence/reason

    ğŸ”“ set_trading_api()
       Docstring:
         Inject DecisionTradingAPI after validation.
         
         This is called by BatchOrchestrator after verifying that
         the broker supports all required order types.
         
         Args:
             trading_api: Validated DecisionTradingAPI instance

    ğŸ”’ _update_decision_statistics()
       Docstring:
         Update internal statistics after decision.
         
         Called automatically by execute_decision() template method.
         Now uses typed DecisionLogicStatistics dataclass.
         
         Args:
             decision: Decision that was made
             order_result: OrderResult if trade was executed (can be None)

    ğŸ”“ get_statistics()
       Docstring:
         Get current statistics.
         
         Returns:
             DecisionLogicStatistics instance with current counters

    ğŸ”“ get_config_value()
       Docstring:
         Get configuration value with default fallback.
         
         Helper method for accessing logic-specific config.
         
         Args:
             key: Config key
             default: Default value if key not found
         
         Returns:
             Config value or default

    ğŸ”“ set_performance_logger()
       Docstring:
         Set performance logger for this decision logic.
         
         Called by WorkerCoordinator to enable performance tracking.
         
         Args:
             logger: PerformanceLogDecisionLogic instance

================================================================================
class AggressiveTrend
  Inherits from: AbstractDecisionLogic
  File: framework/decision_logic/core/aggressive_trend.py:61

  Class Docstring:
    Aggressive trend-following strategy using RSI and Envelope.
    
    Unlike SimpleConsensus, this logic:
    - Uses OR instead of AND (single indicator can trigger)
    - Wider thresholds (more signals)
    - Higher risk, potentially higher reward
    
    Configuration options:
    - rsi_buy_threshold: RSI level for buy signal (default: 35)
    - rsi_sell_threshold: RSI level for sell signal (default: 65)
    - envelope_extremes: How far from center to trigger (default: 0.25)
    - min_confidence: Minimum confidence required (default: 0.4)
    - min_free_margin: Minimum free margin required for trades (default: 1000)
    - lot_size: Fixed lot size for orders (default: 0.1)

  Methods (9):

    ğŸ”’ __init__()
       Docstring:
         Initialize Aggressive Trend logic.
         
         No longer accepts trading_env parameter.
         
         Args:
             name: Logic identifier
             config: Configuration dict with thresholds

    ğŸ”“ get_required_order_types()
       Docstring:
         Declare required order types for this strategy.
         
         AggressiveTrend uses only Market orders for MVP.
         Same as SimpleConsensus - demonstrates standardization.
         
         Returns:
             List containing OrderType.MARKET

    ğŸ”’ _execute_decision_impl()
       Docstring:
         Implementation: Execute trading decision via DecisionTradingAPI.
         
         ONE POSITION ONLY Strategy:
         1. FLAT signal â†’ Close existing position (exit)
         2. Same direction signal â†’ Skip (already have what we want)
         3. Opposite direction signal â†’ Close old, open new (reversal)
         4. New signal with no position â†’ Open position (entry)
         
         Note: get_open_positions() automatically excludes positions being closed.
         Latency simulation is handled internally by TradeSimulator.
         
         Args:
             decision: Decision object from compute()
             tick: Current tick data
         
         Returns:
             OrderResult if order was sent, None if no trade

    ğŸ”“ get_required_worker_instances()
       Docstring:
         Define required worker instances for AggressiveTrend strategy.
         
         Requires:
         - rsi_fast: Fast RSI indicator for trend detection
         - envelope_main: Envelope for price position analysis
         
         Returns:
             Dict[instance_name, worker_type]

    ğŸ”“ compute()
       Docstring:
         Generate trading decision using OR logic (aggressive).
         
         Unlike SimpleConsensus, this strategy triggers on ANY single
         indicator showing an extreme value - no consensus required.
         
         Args:
             tick: Current tick data
             worker_results: Results from rsi and envelope workers
             current_bars: Current bars (not used)
             bar_history: Historical bars (not used)
         
         Returns:
             Decision object with action, confidence, and reason

    ğŸ”’ _calculate_buy_confidence()
       Docstring:
         Calculate buy signal confidence (OR logic allows partial confidence)

    ğŸ”’ _calculate_sell_confidence()
       Docstring:
         Calculate sell signal confidence (OR logic allows partial confidence)

    ğŸ”’ _build_buy_reason()
       Docstring:
         Build explanation for buy signal

    ğŸ”’ _build_sell_reason()
       Docstring:
         Build explanation for sell signal

================================================================================
class SimpleConsensus
  Inherits from: AbstractDecisionLogic
  File: framework/decision_logic/core/simple_consensus.py:55

  Class Docstring:
    Simple consensus strategy using RSI and Envelope indicators.
    
    This is a conservative strategy that requires confirmation from
    both indicators before generating buy/sell signals.
    
    Configuration options:
    - rsi_oversold: RSI threshold for oversold (default: 30)
    - rsi_overbought: RSI threshold for overbought (default: 70)
    - envelope_lower_threshold: Price position threshold for buy (default: 0.3)
    - envelope_upper_threshold: Price position threshold for sell (default: 0.7)
    - min_confidence: Minimum confidence to generate signal (default: 0.5)
    - min_free_margin: Minimum free margin required for trades (default: 1000)
    - lot_size: Fixed lot size for orders (default: 0.1)

  Methods (7):

    ğŸ”’ __init__()
       Docstring:
         Initialize Simple Consensus logic.
         
         No longer accepts trading_env parameter.
         
         Args:
             name: Logic identifier
             config: Configuration dict with thresholds

    ğŸ”“ get_required_order_types()
       Docstring:
         Declare required order types for this strategy.
         
         SimpleConsensus uses only Market orders for MVP.
         Post-MVP: Could use Limit orders for better entry prices.
         
         Returns:
             List containing OrderType.MARKET

    ğŸ”’ _execute_decision_impl()
       Docstring:
         Implementation: Execute trading decision via DecisionTradingAPI.
         
         ONE POSITION ONLY Strategy:
         1. FLAT signal â†’ Close existing position (exit)
         2. Same direction signal â†’ Skip (already have what we want)
         3. Opposite direction signal â†’ Close old, open new (reversal)
         4. New signal with no position â†’ Open position (entry)
         
         Note: get_open_positions() automatically excludes positions being closed.
         Latency simulation is handled internally by TradeSimulator.
         
         Args:
             decision: Decision object from compute()
             tick: Current tick data
         
         Returns:
             OrderResult if order was sent, None if no trade

    ğŸ”“ get_required_worker_instances()
       Docstring:
         Define required worker instances for AggressiveTrend strategy.
         
         Requires:
         - rsi_fast: Fast RSI indicator for trend detection
         - envelope_main: Envelope for price position analysis
         
         Returns:
             Dict[instance_name, worker_type]

    ğŸ”“ compute()
       Docstring:
         Generate trading decision based on consensus between RSI and Envelope.
         
         This is a conservative strategy - BOTH indicators must agree before
         generating a buy/sell signal.
         
         Args:
             tick: Current tick data
             worker_results: Results from rsi and envelope workers
             current_bars: Current bars (not used in simple strategy)
             bar_history: Historical bars (not used in simple strategy)
         
         Returns:
             Decision object with action, confidence, and reason

    ğŸ”’ _calculate_buy_confidence()
       Docstring:
         Calculate buy signal confidence based on indicator extremes.
         
         More extreme values = higher confidence.
         
         Args:
             rsi_value: Current RSI value
             envelope_position: Current envelope position
         
         Returns:
             Confidence score (0.0 - 1.0)

    ğŸ”’ _calculate_sell_confidence()
       Docstring:
         Calculate sell signal confidence based on indicator extremes.
         
         More extreme values = higher confidence.
         
         Args:
             rsi_value: Current RSI value
             envelope_position: Current envelope position
         
         Returns:
             Confidence score (0.0 - 1.0)

================================================================================
class ConfigurationError
  Inherits from: Exception
  File: framework/exceptions/configuration_errors.py:6

  Class Docstring:
    Base class for all configuration errors

  Methods (1):

    ğŸ”“ get_context()
       Docstring:
         Get error context for logger

================================================================================
class ScenarioSetConfigurationError
  Inherits from: ConfigurationError
  File: framework/exceptions/configuration_errors.py:14

  Class Docstring:
    Raised when not enough ticks available for tick-limited mode.
    
    Used in: Modus A (max_ticks mode)

  Methods (2):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_context()
       âš ï¸  NO DOCSTRING

================================================================================
class DataValidationError
  Inherits from: Exception
  File: framework/exceptions/data_validation_errors.py:12

  Class Docstring:
    Base class for all data validation errors

  Methods (1):

    ğŸ”“ get_context()
       Docstring:
         Get error context for logger

================================================================================
class InsufficientTickDataError
  Inherits from: DataValidationError
  File: framework/exceptions/data_validation_errors.py:20

  Class Docstring:
    Raised when not enough ticks available for tick-limited mode.
    
    Used in: Modus A (max_ticks mode)

  Methods (2):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_context()
       âš ï¸  NO DOCSTRING

================================================================================
class CriticalGapError
  Inherits from: DataValidationError
  File: framework/exceptions/data_validation_errors.py:66

  Class Docstring:
    Raised when critical gaps detected in test timespan.
    
    Used in: Modus B (timespan mode)

  Methods (2):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_context()
       âš ï¸  NO DOCSTRING

================================================================================
class NoDataAvailableError
  Inherits from: DataValidationError
  File: framework/exceptions/data_validation_errors.py:123

  Class Docstring:
    Raised when no data found for symbol/period.
    
    Used in: Initial data load

  Methods (2):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_context()
       âš ï¸  NO DOCSTRING

================================================================================
class NoTicksInTimespanError
  Inherits from: DataValidationError
  File: framework/exceptions/data_validation_errors.py:160

  Class Docstring:
    Raised when no ticks found in specified timespan.
    
    Used in: Modus B (timespan mode) when test_df is empty

  Methods (2):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_context()
       âš ï¸  NO DOCSTRING

================================================================================
class InvalidDateRangeError
  Inherits from: DataValidationError
  File: framework/exceptions/data_validation_errors.py:200

  Class Docstring:
    Raised when scenario has invalid date range.
    
    Used in: config_loader validation

  Methods (2):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_context()
       âš ï¸  NO DOCSTRING

================================================================================
class ScenarioPreparationError
  Inherits from: Exception
  File: framework/exceptions/scenario_execution_errors.py:11

  Class Docstring:
    Raised when scenario preparation (warmup phase) fails.
    
    This includes failures in:
    - Data loading
    - Worker creation
    - Trade simulator setup
    - Bar rendering preparation
    
    Scenarios that fail preparation are excluded from execution.

================================================================================
class ScenarioExecutionError
  Inherits from: Exception
  File: framework/exceptions/scenario_execution_errors.py:26

  Class Docstring:
    Raised when scenario tick loop execution fails.
    
    This includes failures during:
    - Tick processing
    - Signal generation
    - Order execution
    - Statistics collection
    
    Execution errors are logged but do not stop other scenarios.

================================================================================
class ScenarioStateError
  Inherits from: Exception
  File: framework/exceptions/scenario_execution_errors.py:41

  Class Docstring:
    Raised when execute_tick_loop() is called without prior prepare_scenario().
    
    ScenarioExecutor requires two-phase execution:
    1. prepare_scenario() - warmup and setup
    2. execute_tick_loop() - actual tick processing
    
    Calling execute_tick_loop() without preparation is a programming error.

================================================================================
class ScenarioExecutionError
  Inherits from: Exception
  File: framework/exceptions/scenario_execution_errors.py:54

  Class Docstring:
    Base exception for scenario execution errors.

================================================================================
class ScenarioPreparationError
  Inherits from: ScenarioExecutionError
  File: framework/exceptions/scenario_execution_errors.py:59

  Class Docstring:
    Raised when scenario preparation fails.

================================================================================
class WarmupBarValidationError
  Inherits from: ScenarioExecutionError
  File: framework/exceptions/scenario_execution_errors.py:64

  Class Docstring:
    Raised when warmup bar validation fails.
    
    Fast performance check - counts only, no temporal validation.
    Used in BarRenderingController.inject_warmup_bars().

================================================================================
class BatchExecutionError
  Inherits from: ScenarioExecutionError
  File: framework/exceptions/scenario_execution_errors.py:74

  Class Docstring:
    Raised when one or more scenarios fail during batch execution.
    
    Contains details of all failed scenarios for comprehensive error reporting.
    Allows batch to continue executing remaining scenarios.
    
    WORKFLOW:
    1. Batch executes all scenarios (some may fail)
    2. Successful scenarios return ProcessResult(success=True)
    3. Failed scenarios return ProcessResult(success=False, error=...)
    4. After all execution, if failures exist: raise BatchExecutionError
    
    Attributes:
        failed_results: List of ProcessResult objects with success=False
        failed_count: Number of failed scenarios

  Methods (4):

    ğŸ”’ __init__()
       Docstring:
         Initialize batch execution error.
         
         Args:
             failed_results: List of failed ProcessResult objects

    ğŸ”“ get_message()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_failed_scenario_names()
       Docstring:
         Get list of failed scenario names.

    ğŸ”“ get_failure_summary()
       Docstring:
         Get short summary of failures.

================================================================================
class InsufficientHistoricalDataError
  Inherits from: Exception
  File: framework/exceptions/warmup_errors.py:10

  Class Docstring:
    Raised when historical data doesn't cover required warmup period.
    
    This occurs when the earliest available tick is later than
    the required warmup start time.

  Methods (1):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

================================================================================
class InsufficientWarmupDataError
  Inherits from: Exception
  File: framework/exceptions/warmup_errors.py:65

  Class Docstring:
    Raised when not enough bars could be rendered for warmup.
    
    This occurs when tick data exists but doesn't render enough
    complete bars for the required warmup period.

  Methods (1):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

================================================================================
class BrokerConfigFactory
  File: framework/factory/broker_config_factory.py:29

  Class Docstring:
    Factory for creating and serializing BrokerConfig instances.

  Methods (3):

    ğŸ”“ build_broker_config()
       Docstring:
         Load broker config from JSON file (Main Process only).
         
         Args:
             config_path: Path to broker JSON config
         
         Returns:
             BrokerConfig instance with adapter
         
         Raises:
             FileNotFoundError: If config file not found
             ValueError: If broker type unknown or unsupported

    ğŸ”“ to_serializable_dict()
       Docstring:
         Serialize broker config to dict for ProcessDataPackage.
         
         Returns raw JSON dict - already CoW-safe and pickleable.
         Subprocess can re-hydrate adapter from this dict.
         
         Args:
             broker_config: BrokerConfig instance
         
         Returns:
             Serializable dict (original JSON data)

    ğŸ”“ from_serialized_dict()
       Docstring:
         Re-hydrate broker config from serialized dict (Subprocess).
         
         No file I/O - adapter is created from dict in memory.
         Used in subprocesses to avoid redundant JSON loading.
         
         Args:
             config_dict: Serialized broker config dict
             config_path: Optional path for error messages
         
         Returns:
             BrokerConfig instance with fresh adapter
         
         Raises:
             ValueError: If broker type cannot be determined

================================================================================
class DecisionLogicFactory
  File: framework/factory/decision_logic_factory.py:37

  Class Docstring:
    Factory for creating decision logic instances from configuration.
    
    This factory provides the same config-driven instantiation pattern
    for decision logics as the Worker Factory does for workers.
    
    It handles:
    1. Namespace resolution (CORE/ â†’ framework, USER/ â†’ custom, etc.)
    2. Dynamic loading and registration
    3. Configuration injection
    4. Validation and error handling

  Methods (9):

    ğŸ”’ __init__()
       Docstring:
         Initialize decision logic factory with empty registry.
         
         The registry is populated lazily when decision logics are requested.
         This avoids import overhead for unused strategies.

    ğŸ”’ _load_core_logics()
       Docstring:
         Pre-register core framework decision logics.
         
         Core decision logics are part of the framework and always available.
         They live in python/framework/decision_logic/core/.
         
         This method is called during factory initialization to ensure
         core strategies are immediately available.

    ğŸ”“ register_logic()
       Docstring:
         Manually register a decision logic class.
         
         This method allows runtime registration of custom decision logics.
         Useful for plugins or dynamically loaded strategies.
         
         Args:
             logic_type: Full logic type with namespace (e.g., "USER/my_strategy")
             logic_class: Logic class (must inherit from AbstractDecisionLogic)
         
         Raises:
             ValueError: If logic_class doesn't inherit from AbstractDecisionLogic

    ğŸ”“ create_logic()
       Docstring:
         Create a decision logic instance from configuration.
         
         No longer accepts trading_env parameter.
         DecisionTradingAPI is injected later via set_trading_api().
         
         This is the main entry point for decision logic creation. It:
         1. Resolves the logic type to a logic class
         2. Instantiates the logic with provided configuration
         3. Returns a ready-to-use decision logic instance
         
         Args:
             logic_type: Logic type with namespace (e.g., "CORE/simple_consensus")
             logic_config: Configuration dict for the logic
         
         Returns:
             Instantiated decision logic ready for use
         
         Raises:
             ValueError: If logic type not found

    ğŸ”“ create_logic_from_strategy_config()
       Docstring:
         Create decision logic from complete strategy configuration.
         
         No longer accepts trading_env parameter.
         DecisionTradingAPI is injected later via set_trading_api().
         
         This is the batch creation method used by orchestrator.
         It extracts the decision logic type and config from strategy_config.
         
         Expected config structure:
         {
             "decision_logic_type": "CORE/simple_consensus",
             "decision_logic_config": {
                 "rsi_oversold": 30,
                 "min_confidence": 0.6
             }
         }
         
         Args:
             strategy_config: Strategy configuration dict
         
         Returns:
             Instantiated decision logic
         
         Raises:
             ValueError: If decision_logic_type not specified or invalid

    ğŸ”’ _resolve_logic_class()
       Docstring:
         Resolve logic type string to logic class.
         
         Supports:
         - CORE/simple_consensus â†’ framework/decision_logic/core/simple_consensus.py
         - USER/my_strategy â†’ decision_logic/user/my_strategy.py
         - BLACKBOX/secret â†’ decision_logic/blackbox/secret.pyc (Post-MVP)
         
         Args:
             logic_type: Full logic type with namespace
         
         Returns:
             Logic class ready for instantiation
         
         Raises:
             ValueError: If logic type not found or invalid

    ğŸ”’ _load_custom_logic()
       Docstring:
         Dynamically load custom decision logic from USER namespace.
         
         BLACKBOX namespace is prepared but feature-gated for Post-MVP.
         
         Args:
             logic_type: Full logic type (e.g., "USER/my_strategy")
         
         Returns:
             Logic class
         
         Raises:
             ValueError: If logic cannot be loaded

    ğŸ”’ _extract_logic_name()
       Docstring:
         Extract simple logic name from full type.
         
         Examples:
             "CORE/simple_consensus" â†’ "simple_consensus"
             "USER/my_custom_strategy" â†’ "my_custom_strategy"
         
         Args:
             logic_type: Full logic type with namespace
         
         Returns:
             Simple logic name

    ğŸ”“ get_registered_logics()
       Docstring:
         Get list of all registered decision logic types.
         
         Useful for debugging and documentation.
         
         Returns:
             List of logic type strings

================================================================================
class WorkerFactory
  File: framework/factory/worker_factory.py:45

  Class Docstring:
    Factory for creating workers from configuration.
    
    This is the central registry and instantiation system for all workers.
    It maintains a mapping of worker names to worker classes and handles
    the complete lifecycle of worker creation.

  Methods (10):

    ğŸ”’ __init__()
       Docstring:
         Initialize worker factory with empty registry.
         
         The registry is populated on-demand when workers are requested.
         This lazy-loading approach avoids import overhead for unused workers.

    ğŸ”’ _load_core_workers()
       Docstring:
         Pre-register core framework workers.
         
         Core workers are part of the framework and always available.
         They live in python/framework/workers/core/.
         
         This method is called during factory initialization to ensure
         core workers are immediately available.

    ğŸ”“ register_worker()
       Docstring:
         Manually register a worker class.
         
         This method allows runtime registration of custom workers.
         Useful for plugins or dynamically loaded workers.
         
         Args:
             worker_type: Full worker type with namespace (e.g., "USER/my_worker")
             worker_class: Worker class (must inherit from AbstractBlackboxWorker)
         
         Raises:
             ValueError: If worker_class doesn't inherit from AbstractBlackboxWorker

    ğŸ”“ create_worker()
       Docstring:
         Create a worker instance with validation.
         
         Keine temp_instance mehr - nutzt classmethods!
         
         New Flow:
         1. Resolve worker class
         2. Get required/optional params via CLASSMETHODS (ohne Instanz!)
         3. Validate required parameters
         4. Merge user config with optional defaults
         5. Instantiate worker ONCE with merged parameters
         
         Args:
             instance_name: User-defined instance name (e.g., "rsi_main")
             worker_type: Worker type with namespace (e.g., "CORE/rsi")
             worker_config: User-provided parameters for this worker
         
         Returns:
             Instantiated worker ready for use
         
         Raises:
             ValueError: If worker type not found or required parameters missing

    ğŸ”“ create_workers_from_config()
       Docstring:
         Create all workers from strategy configuration.
         
         This is the batch creation method used by orchestrator.
         It takes a complete strategy config and creates all declared workers.
         
         Expected config structure:
         {
             "worker_instances": {
                 "rsi_main": "CORE/rsi",
                 "envelope_main": "CORE/envelope"
             },
             "workers": {
                 "rsi_main": {"period": 14, "timeframe": "M5"},
                 "envelope_main": {"period": 20, "deviation": 0.02}
             }
         }
         
         Args:
             strategy_config: Strategy configuration dict
         
         Returns:
             Dict mapping worker instance names to worker instances
         
         Raises:
             ValueError: If config is invalid or worker creation fails

    ğŸ”’ _resolve_worker_class()
       Docstring:
         Resolve worker type string to worker class.
         
         This method handles the namespace-to-class mapping.
         If worker is not in registry, attempts to load it dynamically.
         
         Args:
             worker_type: Full worker type (e.g., "CORE/rsi")
         
         Returns:
             Worker class
         
         Raises:
             ValueError: If worker type not found or invalid

    ğŸ”’ _load_custom_worker()
       Docstring:
         Dynamically load custom worker from USER or BLACKBOX namespace.
         
         This enables hot-loading of custom workers without pre-registration.
         
         Args:
             worker_type: Worker type (e.g., "USER/my_custom_rsi")
         
         Returns:
             Worker class
         
         Raises:
             NotImplementedError: If BLACKBOX namespace (Post-MVP feature)
             ValueError: If worker cannot be loaded

    ğŸ”’ _validate_required_parameters()
       Docstring:
         Validate that all required parameters are provided.
         
         This is a critical validation step that prevents runtime errors
         from missing parameters.
         
         Args:
             worker_type: Worker type (for error messages)
             required_params: Dict of required parameter names and types
             provided_params: User-provided parameters
         
         Raises:
             ValueError: If any required parameter is missing or wrong type

    ğŸ”’ _merge_parameters()
       Docstring:
         Merge user-provided parameters with optional defaults.
         
         User parameters override defaults. This allows workers to have
         sensible defaults while still being fully configurable.
         
         Args:
             optional_defaults: Default values for optional parameters
             provided_params: User-provided parameters
         
         Returns:
             Merged parameter dict (defaults + overrides)

    ğŸ”“ get_registered_workers()
       Docstring:
         Get list of all registered worker types.
         
         Useful for debugging and documentation.
         
         Returns:
             List of worker type strings

================================================================================
class CoordinatorTickLogger
  File: framework/logger/coordinator_tick_logger.py:18

  Class Docstring:
    Optimized logger for tick-by-tick data with intelligent caching.
    
    Features:
    - Always logs: tick, worker results, current bars, decision
    - Caches bar history: only logs when bars actually change
    - JSON format for easy parsing and verification

  Methods (5):

    ğŸ”’ __init__()
       Docstring:
         Initialize logger with caching capability.
         
         Args:
             logger: ScenarioLogger instance from DecisionLogic

    ğŸ”“ log_tick_data()
       Docstring:
         Log complete tick data with intelligent bar history caching.
         
         Logging strategy:
         - Tick: Always logged (changes every tick)
         - Worker Results: Always logged (may change every tick)
         - Current Bars: Always logged (OHLC updates every tick)
         - Bar History: Only logged when changed (new bar completed)
         - Decision: Always logged
         
         Args:
             tick: Current tick data
             worker_results: Results from all workers
             current_bars: Current incomplete bars per timeframe
             bar_history: Historical complete bars per timeframe
             decision: Trading decision for this tick

    ğŸ”’ _build_log_structure()
       Docstring:
         Build the base log data structure.
         
         Args:
             tick: Current tick data
             worker_results: Worker computation results
             current_bars: Current bars per timeframe
             decision: Trading decision
         
         Returns:
             Dictionary with serialized data

    ğŸ”’ _has_bar_history_changed()
       Docstring:
         Detect if bar history changed since last log.
         
         Change detection strategy:
         1. First time logging? â†’ Changed
         2. Different timeframes? â†’ Changed
         3. Different bar count? â†’ Changed
         4. Last bar timestamp different? â†’ Changed (most common)
         
         Args:
             bar_history: Current bar history per timeframe
         
         Returns:
             True if bar history changed, False if cached version is still valid

    ğŸ”’ _update_cache()
       Docstring:
         Update the bar history cache after logging.
         
         Creates a deep copy to avoid reference issues.
         
         Args:
             bar_history: Bar history to cache

================================================================================
class PerformanceLogCoordinator
  File: framework/performance/performance_log_coordinator.py:16

  Class Docstring:
    Coordinates performance logging for an entire scenario.
    
    Creates and manages PerformanceLogWorker instances for each worker
    and a PerformanceLogDecisionLogic instance for the decision logic.
    
    This is the central access point for performance metrics.

  Methods (8):

    ğŸ”’ __init__()
       Docstring:
         Initialize performance coordinator.
         
         Args:
             scenario_name: Name of the scenario being tracked
             parallel_workers: Whether workers run in parallel mode

    ğŸ”“ create_worker_log()
       Docstring:
         Create a performance logger for a worker.
         
         Args:
             worker_type: Worker type (e.g., "CORE/rsi")
             worker_name: Worker instance name (e.g., "RSI_M5")
         
         Returns:
             PerformanceLogWorker instance

    ğŸ”“ create_decision_logic_log()
       Docstring:
         Create a performance logger for decision logic.
         
         Args:
             decision_logic_type: Decision logic type (e.g., "CORE/simple_consensus")
             decision_logic_name: Decision logic instance name (e.g., "SimpleConsensus")
         
         Returns:
             PerformanceLogDecisionLogic instance

    ğŸ”“ record_parallel_time_saved()
       Docstring:
         Record time saved by parallel execution.
         
         Args:
             time_saved_ms: Time saved in milliseconds

    ğŸ”“ increment_ticks()
       Docstring:
         Increment tick counter.

    ğŸ”“ get_snapshot()
       Docstring:
         Get a live snapshot of all performance metrics.
         
         FULLY TYPED: Returns BatchPerformanceStats dataclass.
         This method is designed for minimal overhead so it can be called
         frequently (e.g., every 300ms for TUI updates).
         
         Returns:
             BatchPerformanceStats with complete performance snapshot

    ğŸ”’ _get_parallel_status()
       Docstring:
         Determine parallel execution status.
         
         Args:
             time_saved_ms: Total time saved
         
         Returns:
             Status string

    ğŸ”“ reset()
       Docstring:
         Reset all performance metrics.

================================================================================
class PerformanceLogDecisionLogic
  File: framework/performance/performance_log_decision_logic.py:13

  Class Docstring:
    Performance logger for decision logic.
    
    Tracks decision count, execution times (min/max/avg), and total time consumption.
    Designed for minimal overhead - just accumulates metrics.

  Methods (5):

    ğŸ”’ __init__()
       Docstring:
         Initialize performance logger for decision logic.
         
         Args:
             decision_logic_type: Decision logic type (e.g., "CORE/simple_consensus")
             decision_logic_name: Decision logic instance name (e.g., "SimpleConsensus")

    ğŸ”“ record()
       Docstring:
         Record a single execution time.
         
         Args:
             execution_time_ms: Execution time in milliseconds
             decision: Decision object to track action counts

    ğŸ”“ get_avg_time_ms()
       Docstring:
         Get average execution time in milliseconds.

    ğŸ”“ get_stats()
       Docstring:
         Get performance statistics snapshot.
         
         FULLY TYPED: Returns DecisionLogicPerformanceStats dataclass.
         UNIQUE KEYWORDS: 'logic_*' for type/name, 'decision_*' for metrics.
         
         Returns:
             DecisionLogicPerformanceStats with all performance metrics

    ğŸ”“ reset()
       Docstring:
         Reset all metrics to initial state.

================================================================================
class PerformanceLogWorker
  File: framework/performance/performance_log_worker.py:12

  Class Docstring:
    Performance logger for a single worker.
    
    Tracks call count, execution times (min/max/avg), and total time consumption.
    Designed for minimal overhead - just accumulates metrics.

  Methods (5):

    ğŸ”’ __init__()
       Docstring:
         Initialize performance logger for a worker.
         
         Args:
             worker_type: Worker type (e.g., "CORE/rsi")
             worker_name: Worker instance name (e.g., "RSI_M5")

    ğŸ”“ record()
       Docstring:
         Record a single execution time.
         
         Args:
             execution_time_ms: Execution time in milliseconds

    ğŸ”“ get_avg_time_ms()
       Docstring:
         Get average execution time in milliseconds.

    ğŸ”“ get_stats()
       Docstring:
         Get performance statistics snapshot.
         
         FULLY TYPED: Returns WorkerPerformanceStats dataclass.
         UNIQUE KEYWORDS: All fields prefixed with 'worker_'.
         
         Returns:
             WorkerPerformanceStats with all performance metrics

    ğŸ”“ reset()
       Docstring:
         Reset all metrics to initial state.

================================================================================
class ProcessExecutor
  File: framework/process/process_executor.py:16

  Class Docstring:
    Orchestrates scenario execution.
    
    Wrapper around top-level process functions.
    Provides clean interface for BatchOrchestrator.
    
    DESIGN:
    - Holds scenario and config
    - Calls process_main() (top-level function)
    - Compatible with ThreadPoolExecutor and ProcessPoolExecutor

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize process executor.
         
         CORRECTED: Added scenario_set_name and run_timestamp
         
         Args:
             scenario: Scenario to execute
             app_config: Application configuration
             scenario_index: Index in scenario list
             scenario_set_name: Name of scenario set (for logger)
             run_timestamp: Shared timestamp (for logger)

    ğŸ”“ run()
       Docstring:
         Execute scenario with shared data.
         
         Entry point for executor. Calls process_main().
         
         Args:
             shared_data: Prepared shared data
         
         Returns:
             ProcessResult with execution results

================================================================================
class BarIndexReportGenerator
  File: framework/reporting/bar_index_report.py:20

  Class Docstring:
    Generates comprehensive reports about bar index status.
    
    Reports include:
    - Overview statistics
    - Per-symbol breakdown
    - Per-timeframe statistics
    - Data collector information
    - File locations and sizes

  Methods (7):

    ğŸ”’ __init__()
       Docstring:
         Initialize report generator.
         
         Args:
             index_manager: Initialized BarsIndexManager

    ğŸ”“ generate_report()
       Docstring:
         Generate complete bar index report.
         
         Returns:
             Path to saved report file

    ğŸ”’ _generate_metadata()
       Docstring:
         Generate report metadata

    ğŸ”’ _generate_overview()
       Docstring:
         Generate overview statistics

    ğŸ”’ _generate_symbol_details()
       Docstring:
         Generate detailed per-symbol information

    ğŸ”’ _generate_collector_summary()
       Docstring:
         Generate data collector summary

    ğŸ”’ _save_report()
       Docstring:
         Save report to JSON file.
         
         Args:
             report: Report dictionary
         
         Returns:
             Path to saved report

================================================================================
class BatchSummary
  File: framework/reporting/batch_summary.py:24

  Class Docstring:
    Main summary orchestrator for batch execution results.

  Methods (5):

    ğŸ”’ __init__()
       Docstring:
         Initialize batch summary.
         
         Args:
             performance_log_coordinator: Performance statistics container (includes portfolio stats)
             app_config: AppConfigManager instance

    ğŸ”“ build_profiling_data_map()
       âš ï¸  NO DOCSTRING

    ğŸ”“ render_all()
       Docstring:
         Render complete batch summary.
         
         Sequence:
         1. Header with basic stats
         2. Scenario details (grid)
         3. Portfolio summaries (per scenario + aggregated)
         4. Performance details (per scenario + aggregated)
         5. Bottleneck analysis
         6. Profiling analysis (NEW)
         7. Worker decision breakdown (NEW)

    ğŸ”’ _render_basic_stats()
       Docstring:
         Render basic execution statistics (top-level summary).

    ğŸ”’ _render_scenario_grid()
       Docstring:
         Render scenario details in grid format.

================================================================================
class BrokerInfoRenderer
  File: framework/reporting/broker_info_renderer.py:10

  Class Docstring:
    Renders broker configuration in various formats for logs and reports.

  Methods (4):

    ğŸ”“ render_detailed()
       Docstring:
         Render detailed broker info for scenario logs.
         
         Args:
             broker_spec: Broker specification
             symbol_spec: Optional symbol specification
             indent: Line indentation prefix
         
         Returns:
             Multi-line formatted string

    ğŸ”“ render_single_line()
       Docstring:
         Render single-line broker info for global logs.
         
         Args:
             broker_spec: Broker specification
             symbol: Optional symbol name
         
         Returns:
             Single-line formatted string

    ğŸ”“ render_summary_table()
       Docstring:
         Render broker info as table for batch summaries.
         
         Args:
             broker_spec: BrokerSpecification object
             scenarios: List of scenario names
             indent: Line indentation
         
         Returns:
             Multi-line table string

    ğŸ”“ render_symbols_table()
       Docstring:
         Render symbols table for batch summaries.
         
         Args:
             symbol_specs: List of symbol specifications
             indent: Line indentation
         
         Returns:
             Multi-line table string

================================================================================
class BrokerSummary
  File: framework/reporting/broker_summary.py:14

  Class Docstring:
    Renders broker configuration summary for batch reports.

  Methods (3):

    ğŸ”’ __init__()
       Docstring:
         Initialize broker summary.
         
         Args:
             batch_summary: Batch execution results
             app_config: Application configuration

    ğŸ”’ _collect_broker_data()
       Docstring:
         Collect broker configuration and symbols from scenarios.

    ğŸ”“ render()
       Docstring:
         Render broker summary section.
         
         Args:
             renderer: Console renderer for formatting

================================================================================
class ConsoleBoxRenderer
  File: framework/reporting/console_box_renderer.py:22

  Class Docstring:
    Renders scenario and portfolio statistics as formatted console boxes.
    
    Supports both success and error states with proper line alignment
    for grid rendering.

  Methods (10):

    ğŸ”’ __init__()
       Docstring:
         Initialize box renderer.
         
         Args:
             renderer: ConsoleRenderer instance (for colors, padding, box borders)
             config: Box render configuration (uses defaults if None)

    ğŸ”“ create_scenario_box()
       Docstring:
         Create box lines for scenario statistics.
         
         Dispatches to appropriate handler based on execution state:
         - Success: Normal statistics with status line
         - Error only: Error display (NO status line - self-explanatory)
         - Hybrid (success + errors): CRITICAL warning
         
         Args:
             scenario: ProcessResult object
             box_width: Total box width
         
         Returns:
             List of formatted box lines

    ğŸ”“ create_portfolio_box()
       Docstring:
         Create box lines for portfolio statistics.
         
         Dispatches to appropriate handler based on execution state:
         - Success: Normal portfolio stats with status line
         - Error only: Minimal error display (NO redundant error message)
         - Hybrid (success + errors): CRITICAL warning
         
         Args:
             scenario: ProcessResult object
             box_width: Total box width
         
         Returns:
             List of formatted box lines

    ğŸ”’ _create_success_scenario_box()
       Docstring:
         Create scenario box for successful execution.
         
         Args:
             scenario: ProcessResult with success=True
             box_width: Total box width
         
         Returns:
             List of formatted box lines (10 content lines: 9 stats + 1 status)

    ğŸ”’ _create_success_portfolio_box()
       Docstring:
         Create portfolio box for successful execution.
         
         Args:
             scenario: ProcessResult with success=True
             box_width: Total box width
         
         Returns:
             List of formatted box lines (12 content lines: 11 stats + 1 status)

    ğŸ”’ _create_hybrid_scenario_box()
       Docstring:
         Create scenario box for hybrid case (execution completed BUT errors present).
         
         This is a CRITICAL state that should never occur in production.
         Indicates process recovered from error but errors were logged.
         
         Args:
             scenario: ProcessResult with tick_loop_results AND errors
             box_width: Total box width
         
         Returns:
             List of formatted box lines with CRITICAL warning (replaces success status)

    ğŸ”’ _create_hybrid_portfolio_box()
       Docstring:
         Create portfolio box for hybrid case (execution completed BUT errors present).
         
         This is a CRITICAL state that should never occur in production.
         Indicates process recovered from error but errors were logged.
         
         Args:
             scenario: ProcessResult with portfolio_stats AND errors
             box_width: Total box width
         
         Returns:
             List of formatted box lines with CRITICAL warning (replaces success status)

    ğŸ”’ _create_scenario_error_box()
       Docstring:
         Create scenario error box for failed scenarios.
         
         Displays scenario name, symbol, error type, and wrapped error message.
         NO status line (self-explanatory via âŒ and red text).
         More lines available for error message display.
         
         Args:
             scenario: ProcessResult with success=False
             box_width: Total box width
         
         Returns:
             List of formatted box lines (10 content lines)

    ğŸ”’ _create_portfolio_error_box()
       Docstring:
         Create portfolio error box for failed scenarios.
         
         Minimal display - NO redundant error message.
         Error details are shown in scenario box only.
         
         Args:
             scenario: ProcessResult with success=False
             box_width: Total box width
         
         Returns:
             List of formatted box lines (12 content lines)

    ğŸ”’ _wrap_error_message()
       Docstring:
         Wrap error message to fit box width with intelligent word breaking.
         
         Preserves word boundaries when possible. Truncates with "... (see log)"
         marker if message exceeds available lines.
         
         Args:
             message: Error message to wrap
             width: Maximum line width (characters)
             max_lines: Maximum number of lines
         
         Returns:
             List of wrapped message lines

================================================================================
class ConsoleRenderer
  File: framework/reporting/console_renderer.py:23

  Class Docstring:
    Unified console renderer for all summary outputs.
    
    Handles:
    - Box rendering with perfect symmetry
    - Color formatting
    - Grid layouts
    - Section separators

  Methods (17):

    ğŸ”’ __init__()
       Docstring:
         Initialize console renderer.

    ğŸ”“ red()
       Docstring:
         Color text red.

    ğŸ”“ yellow()
       Docstring:
         Color text yellow.

    ğŸ”“ blue()
       Docstring:
         Color text blue.

    ğŸ”“ green()
       Docstring:
         Color text green.

    ğŸ”“ gray()
       Docstring:
         Color text gray.

    ğŸ”“ bold()
       Docstring:
         Make text bold.

    ğŸ”“ section_header()
       Docstring:
         Print section header.

    ğŸ”“ section_separator()
       Docstring:
         Print section separator.

    ğŸ”“ print_separator()
       Docstring:
         Print simple separator line.

    ğŸ”“ print_bold()
       Docstring:
         Print bold text.

    ğŸ”“ strip_ansi()
       Docstring:
         Remove ANSI color codes from string.
         
         Args:
             text: String potentially containing ANSI codes
         
         Returns:
             String without ANSI codes

    ğŸ”“ visual_length()
       Docstring:
         Get visual length of string (excluding ANSI codes).
         
         Args:
             text: String to measure
         
         Returns:
             Visual length (what user sees)

    ğŸ”“ pad_line()
       Docstring:
         Pad line to exact visual width.
         
         Args:
             text: String to pad (may contain ANSI codes)
             width: Target visual width
         
         Returns:
             Padded string with exact visual width

    ğŸ”“ render_box()
       Docstring:
         Render symmetric box around lines.
         
         Args:
             lines: Lines of text (may contain ANSI codes)
             box_width: Total box width (including borders)
         
         Returns:
             List of box lines ready to print

    ğŸ”“ render_scenario_grid()
       Docstring:
         Render scenarios in grid layout.
         
         Args:
             scenarios: List of Scenario objects
             columns: Number of columns in grid
             box_width: Width of each box

    ğŸ”“ render_portfolio_grid()
       Docstring:
         Render portfolio stats in grid layout.
         
         Args:
             scenarios: List of scenario result dicts with portfolio stats
             columns: Number of columns in grid
             box_width: Width of each box

================================================================================
class CoverageReport
  File: framework/reporting/coverage_report.py:22

  Class Docstring:
    Analyzes time range coverage and generates reports.
    
    Features:
    - Gap detection between files
    - Weekend vs. data loss classification
    - Human-readable reports
    - Actionable recommendations
    - Weekend gap listing with Berlin local time

  Methods (9):

    ğŸ”’ __init__()
       Docstring:
         Initialize coverage report.
         
         Args:
             symbol: Trading symbol
             files: List of index entries (must be sorted chronologically)

    ğŸ”“ analyze()
       Docstring:
         Analyze all files for continuity and gaps.

    ğŸ”“ has_issues()
       Docstring:
         Check if there are any problematic gaps.
         
         Returns:
             True if moderate or large gaps exist

    ğŸ”“ get_recommendations()
       Docstring:
         Generate actionable recommendations based on gaps.
         
         Returns:
             List of recommendation strings

    ğŸ”’ _format_berlin_time()
       Docstring:
         Convert UTC datetime to Berlin local time with timezone label and offset.
         
         Args:
             dt: UTC datetime
         
         Returns:
             Formatted string like "Fri 23:00 CEST (UTC+2)"

    ğŸ”’ _validate_utc_offset()
       Docstring:
         Validate that UTC to Berlin conversion matches expected offset.
         
         Args:
             utc_dt: Original UTC datetime
             berlin_dt: Converted Berlin datetime
             expected_offset_hours: Expected offset in hours (1 or 2)
         
         Returns:
             True if offset is correct

    ğŸ”’ _format_berlin_time_with_validation()
       Docstring:
         Convert UTC to Berlin time with validation check.
         
         Args:
             dt: UTC datetime
         
         Returns:
             Tuple of (formatted_string, is_valid)

    ğŸ”“ generate_report()
       Docstring:
         Generate human-readable coverage report.
         
         Returns:
             Formatted report string

    ğŸ”“ get_summary_dict()
       Docstring:
         Get report summary as dictionary (for programmatic access).
         
         Returns:
             Dict with summary statistics

================================================================================
class PerformanceSummary
  File: framework/reporting/performance_summary.py:27

  Class Docstring:
    Worker and decision logic performance summary.
    
    
    - Uses BatchExecutionSummary for data access
    - FULLY TYPED: Direct attribute access instead of .get()

  Methods (9):

    ğŸ”’ __init__()
       Docstring:
         Initialize performance summary.
         
         Args:
             batch_execution_summary: Batch execution summary containing all scenario results

    ğŸ”“ render_per_scenario()
       Docstring:
         Render performance stats per scenario.
         
         Args:
             renderer: ConsoleRenderer instance

    ğŸ”“ render_aggregated()
       Docstring:
         Render aggregated performance across all scenarios.
         
         Args:
             renderer: ConsoleRenderer instance

    ğŸ”“ render_bottleneck_analysis()
       Docstring:
         Render bottleneck analysis - worst performers.
         
         Args:
             renderer: ConsoleRenderer instance

    ğŸ”’ _render_scenario_performance()
       Docstring:
         Render performance for single scenario.
         
         Args:
             scenario: Scenario result to render
             renderer: ConsoleRenderer instance

    ğŸ”’ _aggregate_performance_stats()
       Docstring:
         Aggregate performance statistics across all scenarios.
         
         Returns:
             Aggregated performance statistics

    ğŸ”’ _render_aggregated_details()
       Docstring:
         Render detailed aggregated performance stats.
         
         Args:
             aggregated: Aggregated performance statistics
             renderer: ConsoleRenderer instance

    ğŸ”’ _analyze_bottlenecks()
       Docstring:
         Analyze performance bottlenecks across all scenarios.
         
         Returns:
             Performance bottleneck analysis

    ğŸ”’ _render_bottleneck_details()
       Docstring:
         Render bottleneck analysis details.
         
         Args:
             bottlenecks: Bottleneck analysis data
             renderer: ConsoleRenderer instance

================================================================================
class PortfolioAggregator
  File: framework/reporting/portfolio_aggregator.py:24

  Class Docstring:
    Aggregates portfolio statistics grouped by currency.
    
    Prevents cross-currency aggregation errors by grouping scenarios
    with same account currency. Validates time divergence to warn
    users about unrealistic aggregations across large time periods.

  Methods (7):

    ğŸ”’ __init__()
       Docstring:
         Initialize aggregator with scenarios.
         
         Args:
             scenarios: List of scenario results to aggregate

    ğŸ”“ aggregate_by_currency()
       Docstring:
         Aggregate scenarios grouped by account currency.
         
         Groups scenarios by their account currency to prevent cross-currency
         conversion errors. Each currency group is aggregated separately.
         
         Returns:
             Dict mapping currency code to aggregated portfolio
             Example: {"USD": AggregatedPortfolio(...), "EUR": ...}

    ğŸ”’ _aggregate_group()
       Docstring:
         Aggregate a single currency group.
         
         Args:
             scenarios: Scenarios in this currency group
             currency: Account currency code
         
         Returns:
             Aggregated portfolio for this currency

    ğŸ”’ _aggregate_portfolio_stats()
       Docstring:
         Aggregate portfolio statistics from scenarios.
         
         Args:
             scenarios: Scenarios to aggregate
         
         Returns:
             Aggregated portfolio stats

    ğŸ”’ _aggregate_order_execution_stats()
       Docstring:
         Aggregate order execution statistics from scenarios.
         
         Args:
             scenarios: Scenarios to aggregate
         
         Returns:
             Aggregated execution stats

    ğŸ”’ _aggregate_cost_breakdown()
       Docstring:
         Aggregate cost breakdown from scenarios.
         
         Args:
             scenarios: Scenarios to aggregate
         
         Returns:
             Aggregated cost breakdown

    ğŸ”’ _validate_time_divergence()
       Docstring:
         Validate time divergence between scenarios.
         
         Calculates the time span between earliest and latest tick across
         all scenarios. Issues warning if span exceeds threshold.
         
         Args:
             scenarios: Scenarios to validate
         
         Returns:
             Tuple of (time_span_days, has_divergence_warning)

================================================================================
class PortfolioSummary
  File: framework/reporting/portfolio_summary.py:16

  Class Docstring:
    Portfolio and trading statistics summary.

  Methods (7):

    ğŸ”’ __init__()
       Docstring:
         Initialize portfolio summary.

    ğŸ”“ render_per_scenario()
       Docstring:
         Render portfolio stats per scenario in BOX format.
         
         Args:
             renderer: ConsoleRenderer instance

    ğŸ”“ render_aggregated()
       Docstring:
         Render aggregated portfolio stats grouped by currency.
         
         Renders separate aggregation for each currency group to avoid
         cross-currency conversion issues.
         
         Args:
             renderer: ConsoleRenderer instance
             aggregated_portfolios: Dict mapping currency to aggregated portfolio

    ğŸ”’ _render_currency_group()
       Docstring:
         Render single currency group aggregation.
         
         Args:
             renderer: ConsoleRenderer instance
             aggregated: Aggregated portfolio for this currency
             show_currency_header: Whether to show currency-specific header

    ğŸ”’ _render_aggregated_details()
       Docstring:
         Render detailed aggregated portfolio stats.

    ğŸ”’ _has_any_time_divergence()
       Docstring:
         Check if any currency group has time divergence warning.
         
         Args:
             aggregated_portfolios: Dict of aggregated portfolios
         
         Returns:
             True if any group has time divergence

    ğŸ”’ _render_aggregation_warnings()
       Docstring:
         Render warnings about aggregation limitations.
         
         Args:
             renderer: ConsoleRenderer instance
             aggregated_portfolios: Dict of aggregated portfolios

================================================================================
class ProfilingSummary
  File: framework/reporting/profiling_summary.py:16

  Class Docstring:
    Performance profiling and bottleneck analysis.
    
    Renders:
    - Per-scenario operation breakdowns
    - Timing percentages
    - Bottleneck identification
    - Cross-scenario comparison
    - Optimization recommendations

  Methods (10):

    ğŸ”’ __init__()
       Docstring:
         Initialize profiling summary.
         
         Args:
             performance_log_coordinator: Performance statistics container

    ğŸ”“ render_per_scenario()
       Docstring:
         Render profiling breakdown per scenario.
         
         Shows:
         - Operation timing table
         - Percentage breakdown
         - Bottleneck identification
         
         Args:
             renderer: ConsoleRenderer instance

    ğŸ”“ render_aggregated()
       Docstring:
         Render aggregated profiling across all scenarios.
         
         Shows:
         - Total ticks processed
         - Average tick time
         - Most common bottleneck
         - Cross-scenario comparison
         
         Args:
             renderer: ConsoleRenderer instance

    ğŸ”“ render_bottleneck_analysis()
       Docstring:
         Render bottleneck analysis and optimization recommendations.
         
         Shows:
         - Bottleneck frequency across scenarios
         - Worst performers
         - Optimization suggestions
         
         Args:
             renderer: ConsoleRenderer instance

    ğŸ”’ _extract_profile_from_scenario()
       Docstring:
         Direct typed access to profiling_data.
         No more nested dict navigation!
         
         Args:
             scenario: ScenarioPerformanceStats object
         
         Returns:
             TickLoopProfile or None if no profiling data

    ğŸ”’ _build_profiling_metrics()
       Docstring:
         Build ProfilingMetrics from all scenarios.

    ğŸ”’ _render_scenario_profile()
       Docstring:
         Render single scenario's profiling breakdown.
         
         Uses smart coloring:
         - Expected operations (worker_decision, order_execution) â†’ green/yellow
         - Infrastructure operations â†’ yellow/red when â‰¥15%

    ğŸ”’ _render_aggregated_details()
       Docstring:
         Render aggregated profiling statistics.

    ğŸ”’ _render_cross_scenario_averages()
       Docstring:
         Render average operation times across all scenarios.

    ğŸ”’ _render_bottleneck_details()
       Docstring:
         Render detailed bottleneck analysis.
         
         Shows ALL operations with their bottleneck frequency.
         Distinguishes between:
         - Expected bottlenecks (strategy work) - marked with âœ…
         - Problematic bottlenecks (infrastructure) - marked with âš ï¸
         - No bottleneck (0%) - marked with -

================================================================================
class WorkerDecisionBreakdownSummary
  File: framework/reporting/worker_decision_breakdown_summary.py:21

  Class Docstring:
    Worker decision breakdown - facts only.
    
    FULLY TYPED: Uses BatchPerformanceStats instead of dicts.
    Uses typed ProfilingData for clean access.

  Methods (9):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ render_per_scenario()
       Docstring:
         Render per scenario breakdown.

    ğŸ”“ render_aggregated()
       Docstring:
         Render aggregated breakdown.

    ğŸ”“ render_overhead_analysis()
       Docstring:
         Render overhead analysis.

    ğŸ”’ _build_breakdowns()
       Docstring:
         Build breakdowns from scenarios.

    ğŸ”’ _build_breakdown_for_scenario()
       Docstring:
         Build breakdown for single scenario.
         
         Uses typed ProfilingData for clean access.
         No more: profiling_data.get('profile_times', {}).get('worker_decision', 0.0)
         Now: profiling_data.get_operation_time('worker_decision')

    ğŸ”’ _render_scenario_breakdown()
       Docstring:
         Render scenario breakdown.

    ğŸ”’ _render_overhead_details()
       Docstring:
         Render overhead analysis.

    ğŸ”’ _create_bar()
       Docstring:
         Create ASCII bar.

================================================================================
class IOrderCapabilities
  Inherits from: ABC
  File: framework/trading_env/adapters/base_adapter.py:26

  Class Docstring:
    Abstract interface for broker order capabilities.
    
    Every broker adapter must implement:
    1. Order creation methods (market, limit, extended)
    2. Capability query methods
    3. Broker-specific configuration loading
    
    Design Philosophy:
    - Common orders (market, limit) are REQUIRED
    - Extended orders (stop, iceberg) are OPTIONAL
    - Adapters declare their capabilities via get_order_capabilities()
    - DecisionLogic queries capabilities at runtime

  Methods (16):

    ğŸ”’ __init__()
       Docstring:
         Initialize adapter with broker configuration.
         
         Args:
             broker_config: Broker-specific config (from JSON or API)

    ğŸ”’ _validate_config()
       Docstring:
         Validate broker configuration.
         
         Called during __init__. Should raise ValueError if config invalid.

    ğŸ”“ get_broker_name()
       Docstring:
         Get broker company name (e.g., 'IC Markets')

    ğŸ”“ get_broker_type()
       Docstring:
         Get broker type identifier (e.g., 'mt5_forex', 'kraken_spot')

    ğŸ”“ get_order_capabilities()
       Docstring:
         Get broker order capabilities.
         
         Returns OrderCapabilities object with all supported features.
         Used by DecisionLogic to check what orders are possible.

    ğŸ”“ create_market_order()
       Docstring:
         Create market order (execute immediately at current price).
         
         ALL brokers MUST implement this.
         
         Args:
             symbol: Trading symbol (e.g., "EURUSD")
             direction: BUY or SELL
             lots: Order size
             **kwargs: Optional params (stop_loss, take_profit, comment)
         
         Returns:
             MarketOrder object ready for execution
         
         Raises:
             ValueError: If parameters invalid

    ğŸ”“ create_limit_order()
       Docstring:
         Create limit order (execute at specified price or better).
         
         ALL brokers MUST implement this.
         
         Args:
             symbol: Trading symbol
             direction: BUY or SELL
             lots: Order size
             price: Limit price
             **kwargs: Optional params (stop_loss, take_profit, expiration)
         
         Returns:
             LimitOrder object ready for execution

    ğŸ”“ create_stop_order()
       Docstring:
         Create stop order (becomes market order when price reached).
         
         OPTIONAL - Not all brokers support this.
         Default implementation raises NotImplementedError.
         
         Override in subclass if broker supports stop orders.

    ğŸ”“ create_stop_limit_order()
       Docstring:
         Create stop-limit order.
         
         OPTIONAL - Not all brokers support this.
         Default implementation raises NotImplementedError.

    ğŸ”“ create_iceberg_order()
       Docstring:
         Create iceberg order (large order split into chunks).
         
         OPTIONAL - Primarily crypto exchanges (Kraken, Binance).
         Default implementation raises NotImplementedError.

    ğŸ”“ validate_order()
       Docstring:
         Validate order parameters against broker limits.
         
         Checks:
         - Symbol is tradeable
         - Lot size within min/max bounds
         - Lot step compliance
         
         Args:
             symbol: Trading symbol
             lots: Order size
         
         Returns:
             (is_valid, error_message)

    ğŸ”“ get_all_aviable_symbols()
       Docstring:
         Return a list of all symbol strings (e.g. ["EURUSD", "GBPUSD"]).

    ğŸ”“ get_symbol_specification()
       Docstring:
         Get fully typed symbol specification.
         
         Returns static symbol properties as typed dataclass.
         Does NOT include dynamic market data (tick_value, bid/ask).
         
         Args:
             symbol: Trading symbol (e.g., "GBPUSD")
         
         Returns:
             SymbolSpecification with all static properties
         
         Raises:
             ValueError: If symbol not found
         
         Example:
             spec = adapter.get_symbol_specification("GBPUSD")
             print(f"Min lot: {spec.volume_min}")
             print(f"Quote currency: {spec.quote_currency}")

    ğŸ”“ get_broker_specification()
       Docstring:
         Get fully typed broker specification.
         
         Returns static broker properties as typed dataclass.
         
         Returns:
             BrokerSpecification with all static broker properties
         
         Example:
             spec = adapter.get_broker_specification()
             print(f"Leverage: 1:{spec.leverage}")
             print(f"Margin call: {spec.margin_call_level}%")

    ğŸ”’ _validate_lot_size()
       Docstring:
         Common lot size validation logic.
         
         Can be reused by all adapters.

    ğŸ”’ _get_config_value()
       Docstring:
         Get nested config value using dot notation.
         
         Example:
             _get_config_value('symbols.EURUSD.volume_min', 0.01)
         
         Args:
             key_path: Dot-separated path (e.g., 'broker_info.leverage')
             default: Default value if key not found
         
         Returns:
             Config value or default

================================================================================
class KrakenAdapter
  Inherits from: IOrderCapabilities
  File: framework/trading_env/adapters/kraken_adapter.py:29

  Class Docstring:
    Kraken Crypto Exchange Adapter - DUMMY IMPLEMENTATION.
    
    Feature Gate: KRAKEN_ENABLED = False
    
    Purpose:
    - Demonstrates adapter architecture
    - Reserves interface for Post-MVP expansion
    - Shows how non-MT5 brokers would be integrated
    
    Kraken-Specific Features (Post-MVP):
    - Maker/Taker fee structure
    - Funding rates for margin positions
    - Iceberg orders (large order splitting)
    - Stop-Limit orders (Kraken supports, MT5 supports)
    - No traditional stop orders (Kraken limitation)
    
    When Implementing Post-MVP:
    1. Set KRAKEN_ENABLED = True
    2. Implement Kraken API client
    3. Replace NotImplementedError with real logic
    4. Add Kraken-specific config schema

  Methods (15):

    ğŸ”’ __init__()
       Docstring:
         Initialize Kraken adapter.
         
         Args:
             broker_config: Kraken-specific configuration
         
         Raises:
             RuntimeError: If KRAKEN_ENABLED = False

    ğŸ”’ _validate_config()
       Docstring:
         Validate Kraken broker configuration

    ğŸ”“ get_broker_name()
       Docstring:
         Get broker name

    ğŸ”“ get_broker_type()
       Docstring:
         Get broker type identifier

    ğŸ”“ get_order_capabilities()
       Docstring:
         Get Kraken order capabilities.
         
         Kraken features:
         - Common: Market, Limit
         - StopLimit, Iceberg
         - NOT supported: Stop (Kraken uses StopLimit instead)

    ğŸ”“ create_market_order()
       Docstring:
         Create Kraken market order (DUMMY).
         
         Post-MVP: Implement Kraken API integration.

    ğŸ”“ create_limit_order()
       Docstring:
         Create Kraken limit order (DUMMY).
         
         Post-MVP: Implement Kraken API integration.

    ğŸ”“ create_stop_limit_order()
       Docstring:
         Create Kraken stop-limit order (DUMMY).
         
         Kraken uses stop-limit as primary stop mechanism.
         No pure stop orders available.
         
         Post-MVP: Implement Kraken API integration.

    ğŸ”“ create_iceberg_order()
       Docstring:
         Create Kraken iceberg order (DUMMY).
         
         Iceberg orders split large orders into smaller visible chunks.
         Kraken-specific feature not available in MT5.
         
         Post-MVP: Implement Kraken API integration.

    ğŸ”“ validate_order()
       Docstring:
         Validate Kraken order (DUMMY).
         
         Post-MVP: Implement Kraken symbol validation.

    ğŸ”“ get_all_aviable_symbols()
       Docstring:
         Return a list of all symbol strings (e.g. ["EURUSD", "GBPUSD"]).

    ğŸ”“ get_symbol_specification()
       Docstring:
         Get Kraken symbol specs (DUMMY).
         
         Post-MVP: Query Kraken API for symbol information.

    ğŸ”“ get_maker_fee()
       Docstring:
         Get maker fee percentage.
         
         Kraken charges different fees for maker vs taker orders.
         Maker = adds liquidity (limit orders)

    ğŸ”“ get_taker_fee()
       Docstring:
         Get taker fee percentage.
         
         Taker = removes liquidity (market orders)

    ğŸ”“ get_funding_rate()
       Docstring:
         Get funding rate for margin positions.
         
         Kraken charges funding rates for leveraged positions.
         Different from Forex swap rates.

================================================================================
class MT5Adapter
  Inherits from: IOrderCapabilities
  File: framework/trading_env/adapters/mt5_adapter.py:30

  Class Docstring:
    MT5 Broker Adapter - Full implementation.
    
    Features:
    - Loads broker_config.json from BrokerConfigExporter.mq5
    - Supports Market, Limit, Stop, StopLimit orders
    - Validates lot sizes, margin requirements
    - Calculates commission from broker config
    
    Configuration Source:
    - mql5/sample_broker_data/broker_config_sample.json

  Methods (17):

    ğŸ”’ __init__()
       Docstring:
         Initialize MT5 adapter with broker configuration.
         
         Args:
             broker_config: Loaded from broker_config.json

    ğŸ”’ _validate_config()
       Docstring:
         Validate MT5 broker configuration structure

    ğŸ”“ get_broker_name()
       Docstring:
         Get broker company name

    ğŸ”“ get_broker_type()
       Docstring:
         Get broker type identifier

    ğŸ”“ get_order_capabilities()
       Docstring:
         Get MT5 order capabilities.
         
         MT5 supports:
         - Common: Market, Limit
         - Stop, StopLimit
         - No support for: TrailingStop (requires live connection), Iceberg

    ğŸ”“ create_market_order()
       Docstring:
         Create MT5 market order.
         
         Args:
             symbol: Trading symbol (e.g., "EURUSD")
             direction: BUY or SELL
             lots: Order size (e.g., 0.1 = 10,000 units for Forex)
             **kwargs: stop_loss, take_profit, max_slippage, comment, magic_number
         
         Returns:
             MarketOrder ready for execution
         
         Raises:
             ValueError: If validation fails

    ğŸ”“ create_limit_order()
       Docstring:
         Create MT5 limit order.
         
         Args:
             symbol: Trading symbol
             direction: BUY or SELL
             lots: Order size
             price: Limit entry price
             **kwargs: stop_loss, take_profit, expiration, comment, magic_number
         
         Returns:
             LimitOrder ready for execution

    ğŸ”“ create_stop_order()
       Docstring:
         Create MT5 stop order.
         
         Stop order becomes market order when stop_price is reached.

    ğŸ”“ create_stop_limit_order()
       Docstring:
         Create MT5 stop-limit order.
         
         Order becomes limit order when stop_price is reached.

    ğŸ”“ validate_order()
       Docstring:
         Validate MT5 order parameters.
         
         Checks:
         - Symbol exists and is tradeable
         - Lot size within broker limits
         - Lot step compliance
         
         Returns:
             (is_valid, error_message)

    ğŸ”“ get_all_aviable_symbols()
       Docstring:
         Return a list of all symbol strings (e.g. ["EURUSD", "GBPUSD"]).

    ğŸ”“ get_symbol_specification()
       Docstring:
         Get fully typed symbol specification.
         
         Returns static symbol properties as typed dataclass.
         Does NOT include dynamic market data (tick_value, bid/ask).
         
         Args:
             symbol: Trading symbol (e.g., "GBPUSD")
         
         Returns:
             SymbolSpecification with all static properties
         
         Raises:
             ValueError: If symbol not found
         
         Example:
             spec = adapter.get_symbol_specification("GBPUSD")
             print(f"Min lot: {spec.volume_min}")
             print(f"Quote currency: {spec.quote_currency}")

    ğŸ”“ get_broker_specification()
       Docstring:
         Get fully typed broker specification.
         
         Returns static broker properties as typed dataclass.
         
         Returns:
             BrokerSpecification with all static broker properties
         
         Example:
             spec = adapter.get_broker_specification()
             print(f"Leverage: 1:{spec.leverage}")
             print(f"Margin call: {spec.margin_call_level}%")

    ğŸ”“ get_leverage()
       Docstring:
         Get account leverage (e.g., 500 for 1:500)

    ğŸ”“ calculate_margin_required()
       Docstring:
         Calculate required margin for order.
         
         Formula (Forex):
         Margin = (Lots * Contract_Size * Current_Price) / Leverage
         
         Args:
             symbol: Trading symbol
             lots: Order size
         
         Returns:
             Required margin in account currency

    ğŸ”“ get_commission_per_lot()
       Docstring:
         Get commission per lot (if configured).
         
         Note: Commission not always exposed in broker_config.json.
         Returns 0.0 if not configured.

    ğŸ”“ is_hedging_allowed()
       Docstring:
         Check if broker allows hedging (opposite positions same symbol)

================================================================================
class BrokerType
  Inherits from: Enum
  File: framework/trading_env/broker_config.py:34

  Class Docstring:
    Supported broker types

================================================================================
class BrokerConfig
  File: framework/trading_env/broker_config.py:43

  Class Docstring:
    Unified broker configuration interface.
    
    Responsibilities:
    - Load broker JSON from ./configs/brokers/
    - Instantiate correct adapter (MT5, Kraken, etc.)
    - Provide unified interface for TradeSimulator
    - Delegate broker-specific operations to adapter
    
    Usage:
        config = BrokerConfig.from_json("./configs/brokers/mt5/ic_markets_demo.json")
    
        # Unified interface
        leverage = config.get_max_leverage("EURUSD")
        margin = config.calculate_margin("EURUSD", 0.1)
    
        # Create orders
        order = config.create_market_order("EURUSD", OrderDirection.LONG, 0.1)

  Methods (23):

    ğŸ”’ __init__()
       Docstring:
         Initialize broker config with adapter.
         
         Args:
             broker_type: Type of broker (MT5_FOREX, KRAKEN_SPOT, etc.)
             adapter: Instantiated broker adapter

    ğŸ”“ load_all_symbol_specs()
       Docstring:
         init all symbols broker delivers in symbols list.

    ğŸ”’ _detect_broker_type()
       Docstring:
         Detect broker type from config structure or file path.
         
         Detection logic:
         1. Check explicit 'broker_type' field in config
         2. Check file path (config/brokers/mt5/*, config/brokers/kraken/*)
         3. Check config structure (presence of MT5-specific fields)
         
         Args:
             config: Loaded broker config dict
             path: Config file path
         
         Returns:
             Detected BrokerType
         
         Raises:
             ValueError: If broker type cannot be determined

    ğŸ”’ _create_adapter()
       Docstring:
         Create appropriate adapter for broker type.
         
         Args:
             broker_type: Detected broker type
             config: Raw broker configuration
         
         Returns:
             Instantiated adapter
         
         Raises:
             ValueError: If broker type not supported

    ğŸ”“ get_broker_name()
       Docstring:
         Get broker company name (e.g., 'IC Markets')

    ğŸ”“ get_broker_type_str()
       Docstring:
         Get broker type as string (e.g., 'mt5_forex')

    ğŸ”“ get_order_capabilities()
       Docstring:
         Get broker order capabilities

    ğŸ”“ get_all_aviable_symbols()
       Docstring:
         get a list of all symbols there are for a broker.

    ğŸ”“ get_symbol_specification()
       Docstring:
         Get fully typed symbol specification.
         
         Returns static symbol properties as typed dataclass.
         Delegates to adapter for broker-specific implementation.
         
         Args:
             symbol: Trading symbol (e.g., "GBPUSD")
         
         Returns:
             SymbolSpecification with all static properties
         
         Raises:
             ValueError: If symbol not found
         
         Example:
             spec = broker_config.get_symbol_specification("GBPUSD")
             is_valid, error = spec.validate_lot_size(0.1)

    ğŸ”“ get_broker_specification()
       Docstring:
         Get fully typed broker specification.
         
         Returns static broker properties as typed dataclass.
         Delegates to adapter for broker-specific implementation.
         
         Returns:
             BrokerSpecification with all static broker properties
         
         Example:
             spec = broker_config.get_broker_specification()
             print(f"Account: {spec.company} ({spec.trade_mode})")
             print(f"Leverage: 1:{spec.leverage}")

    ğŸ”“ get_min_lot_size()
       Docstring:
         Get minimum lot size for symbol

    ğŸ”“ get_max_lot_size()
       Docstring:
         Get maximum lot size for symbol

    ğŸ”“ get_lot_step()
       Docstring:
         Get lot step increment for symbol

    ğŸ”“ get_tick_size()
       Docstring:
         Get minimum price movement for symbol

    ğŸ”“ is_symbol_tradeable()
       Docstring:
         Check if symbol is currently tradeable

    ğŸ”“ create_market_order()
       Docstring:
         Create market order.
         
         Delegates to adapter for broker-specific validation.

    ğŸ”“ create_limit_order()
       Docstring:
         Create limit order

    ğŸ”“ create_stop_order()
       Docstring:
         Create stop order (if supported).
         
         Raises:
             NotImplementedError: If broker doesn't support stop orders

    ğŸ”“ create_stop_limit_order()
       Docstring:
         Create stop-limit order (if supported).
         
         Raises:
             NotImplementedError: If broker doesn't support stop-limit

    ğŸ”“ create_iceberg_order()
       Docstring:
         Create iceberg order (if supported).
         
         Raises:
             NotImplementedError: If broker doesn't support iceberg orders

    ğŸ”“ validate_order()
       Docstring:
         Validate order parameters.
         
         Returns:
             (is_valid, error_message)

    ğŸ”“ get_max_leverage()
       Docstring:
         Get maximum leverage (if applicable).
         
         MT5: Account-level leverage (e.g., 500)
         Kraken: Symbol-specific leverage (e.g., 5 for crypto)
         
         Args:
             symbol: Optional symbol (some brokers have symbol-specific leverage)
         
         Returns:
             Maximum leverage multiplier

    ğŸ”“ calculate_margin()
       Docstring:
         Calculate required margin for order.
         
         Only available for brokers with margin trading (MT5, Kraken margin).
         
         Args:
             symbol: Trading symbol
             lots: Order size
         
         Returns:
             Required margin in account currency

================================================================================
class DecisionTradingAPI
  File: framework/trading_env/decision_trading_api.py:46

  Class Docstring:
    Public API for Decision Logic trading operations.
    
    This class acts as a gatekeeper between Decision Logic and TradeSimulator,
    providing only safe, validated operations.
    
    Key Features:
    - Order-type validation at creation time (BEFORE scenario runs)
    - Clean public API (only what Decision Logics need)
    - Framework retains full TradeSimulator access
    - Interface compatible with future FiniexAutoTrader integration

  Methods (13):

    ğŸ”’ __init__()
       Docstring:
         Initialize Decision Trading API with order-type validation.
         
         Args:
             trade_simulator: TradeSimulator instance for this scenario
             required_order_types: Order types that Decision Logic will use
         
         Raises:
             ValueError: If any required order type is not supported by broker

    ğŸ”’ _validate_order_types()
       Docstring:
         Validate that broker supports all required order types.
         
         This is the core safety mechanism - prevents runtime failures
         by catching unsupported order types at scenario creation time.
         
         Args:
             required_types: List of OrderType that Decision Logic needs
         
         Raises:
             ValueError: If any order type not supported by broker
         
         Example:
             # Decision Logic requires Market + Limit
             required = [OrderType.MARKET, OrderType.LIMIT]
         
             # But broker only supports Market
             # â†’ ValueError raised BEFORE scenario starts
             # â†’ Clear error message to user
             # â†’ No wasted computation on invalid scenario

    ğŸ”’ _get_supported_order_types()
       Docstring:
         Get list of order types supported by broker

    ğŸ”“ send_order()
       Docstring:
         Send order to trading environment.
         
         This is the main entry point for Decision Logics to execute trades.
         Order-type validation already happened in __init__, so this will
         only fail due to runtime issues (insufficient margin, etc).
         
         Args:
             symbol: Trading symbol (e.g., "EURUSD")
             order_type: OrderType.MARKET or OrderType.LIMIT (MVP)
             direction: OrderDirection.LONG or OrderDirection.SHORT
             lots: Position size
             **kwargs: Optional params (stop_loss, take_profit, price for limit)
         
         Returns:
             OrderResult with execution details
         
         Example:
             result = self.trading_api.send_order(
                 symbol="EURUSD",
                 order_type=OrderType.MARKET,
                 direction=OrderDirection.LONG,
                 lots=0.1,
                 stop_loss=1.0950,
                 take_profit=1.1050
             )

    ğŸ”“ get_account_info()
       Docstring:
         Get current account information.
         
         Returns account state including:
         - balance: Total account balance
         - equity: Balance + unrealized P&L
         - margin_used: Margin locked in open positions
         - free_margin: Available margin for new trades
         - margin_level: (equity / margin_used) * 100
         
         Returns:
             AccountInfo dataclass with all account metrics

    ğŸ”“ get_open_positions()
       Docstring:
         Get list of open positions.
         
         Args:
             symbol: Filter by symbol (None = all positions)
         
         Returns:
             List of Position objects with details:
             - position_id: Unique identifier
             - symbol: Trading symbol
             - direction: BUY or SELL
             - lots: Position size
             - open_price: Entry price
             - current_price: Current market price
             - unrealized_pnl: Floating profit/loss
             - stop_loss: SL level (if set)
             - take_profit: TP level (if set)
         
         Example:
             positions = self.trading_api.get_open_positions("EURUSD")
             for pos in positions:
                 if pos.unrealized_pnl < -100:
                     self.close_position(pos.position_id)

    ğŸ”“ get_position()
       Docstring:
         Get specific position by ID.
         
         Args:
             position_id: Position identifier
         
         Returns:
             Position object or None if not found

    ğŸ”“ close_position()
       Docstring:
         Close position (full or partial).
         
         Args:
             position_id: Position to close
             lots: Lots to close (None = close all)
         
         Returns:
             OrderResult with close execution details

    ğŸ”“ get_order_capabilities()
       Docstring:
         Get broker order capabilities.
         
         Useful for Decision Logics that want to check capabilities
         at runtime (though validation already happened in __init__).
         
         Returns:
             OrderCapabilities object with supported features
         
         Example:
             caps = self.trading_api.get_order_capabilities()
             if caps.trailing_stop:
                 # Use trailing stop
                 pass

    ğŸ”“ get_broker_name()
       Docstring:
         Get name of connected broker

    ğŸ”“ get_leverage()
       Docstring:
         Get leverage for symbol.
         
         Args:
             symbol: Trading symbol (None = default leverage)
         
         Returns:
             Leverage multiplier (e.g., 100.0 for 1:100)

    ğŸ”“ modify_position()
       Docstring:
         Modify position stop loss and take profit.
         
         Post-MVP: Will allow dynamic SL/TP management.
         MVP: Not implemented.
         
         Args:
             position_id: Position to modify
             stop_loss: New SL level (None = no change)
             take_profit: New TP level (None = no change)
         
         Returns:
             True if modification successful

    ğŸ”“ get_order_history()
       Docstring:
         Get historical orders (executed + rejected).
         
         Post-MVP: Will provide full order history for analysis.
         MVP: Not implemented.
         
         Args:
             symbol: Filter by symbol (None = all orders)
         
         Returns:
             List of OrderResult objects

================================================================================
class SeededDelayGenerator
  File: framework/trading_env/order_latency_simulator.py:48

  Class Docstring:
    Generate deterministic random delays using seeds.
    
    Uses Python's random.Random with explicit seed for reproducibility.
    Every run with same seed produces identical delay sequence.
    
    NOTE: Currently tick-based (ticks to wait).
    Post-MVP: Will be MS-based with tickâ†’timestamp mapping.

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize delay generator.
         
         Args:
             seed: Random seed for reproducibility
             min_delay: Minimum delay in ticks (MVP) / ms (Post-MVP)
             max_delay: Maximum delay in ticks (MVP) / ms (Post-MVP)

    ğŸ”“ next()
       Docstring:
         Generate next delay value.
         
         Returns:
             Random delay between min_delay and max_delay (inclusive)

================================================================================
class OrderLatencySimulator
  File: framework/trading_env/order_latency_simulator.py:86

  Class Docstring:
    Manages order lifecycle with deterministic delays.
    
    Simulates realistic broker behavior:
    1. Order submitted â†’ PENDING status
    2. API latency delay (order reaches broker)
    3. Market execution delay (broker matches order)
    4. Order filled â†’ EXECUTED status
    
    All delays are seeded for reproducibility across runs.
    This allows testing strategies with consistent execution
    conditions while maintaining realistic timing behavior.

  Methods (7):

    ğŸ”’ __init__()
       Docstring:
         Initialize latency simulator with seeds and logger.
         
         Args:
             seeds: Dictionary with seed values:
                 - api_latency_seed: Seed for API delay generator
                 - market_execution_seed: Seed for execution delay generator
             logger: Logger instance for tracking order flow
         
         Default seeds used if not provided:
             - api_latency_seed: 42
             - market_execution_seed: 123

    ğŸ”“ submit_open_order()
       Docstring:
         Submit OPEN order for execution with delay.
         
         Order enters PENDING state and will be filled after
         combined API + execution delay.
         
         Args:
             symbol: Trading symbol
             direction: "long" or "short"
             lots: Position size
             current_tick: Current tick number
             **kwargs: Additional order parameters (SL, TP, comment)
         
         Returns:
             order_id: Unique identifier for this order

    ğŸ”“ submit_close_order()
       Docstring:
         Submit CLOSE order for execution with delay.
         
         Close orders use same delay system as open orders for realism.
         
         Args:
             position_id: Position to close
             current_tick: Current tick number
             close_lots: Lots to close (None = close all)
         
         Returns:
             order_id: Unique identifier for this close order

    ğŸ”“ process_tick()
       Docstring:
         Process current tick and return orders ready to fill.
         
         Checks all pending orders and returns those whose
         fill_at_tick has been reached or passed.
         
         Args:
             tick_number: Current tick number
         
         Returns:
             List of PendingOrder objects ready to be filled

    ğŸ”“ get_pending_count()
       Docstring:
         Get number of pending orders.
         
         Useful for debugging and statistics.

    ğŸ”“ get_pending_orders()
       Docstring:
         Get pending orders, optionally filtered by action type.
         
         Args:
             filter_pending_action: Optional filter (OPEN or CLOSE)
                                   None returns all pending orders
         
         Returns:
             List of PendingOrder objects matching the filter
         
         Example:
             # Get only pending CLOSE orders
             closes = simulator.get_pending_orders(PendingOrderAction.CLOSE)
         
             # Get all pending orders
             all_pending = simulator.get_pending_orders()

    ğŸ”“ clear_pending()
       Docstring:
         Clear all pending orders.
         
         Used when scenario ends to prevent orders from
         previous scenarios leaking into next scenario.

================================================================================
class PortfolioManager
  File: framework/trading_env/portfolio_manager.py:27

  Class Docstring:
    Portfolio Manager - Tracks account state and positions.
    
    :
    - Direct attributes for statistics (no nested _statistics object)
    - CostBreakdown object for _cost_tracking (separate concern)
    - Always-copy public API for safety
    - FULLY TYPED: Returns dataclasses instead of dicts
    - CURRENCY: Uses 'account_currency' instead of 'currency' for clarity

  Methods (24):

    ğŸ”’ __init__()
       Docstring:
         Initialize portfolio manager.
         
         Args:
             initial_balance: Starting balance
             account_currency: Account currency (e.g., "USD", "EUR", "JPY")
             broker_config: Broker configuration (for symbol specifications)
             leverage: Account leverage
             margin_call_level: Margin call threshold percentage
             stop_out_level: Stop out threshold percentage

    ğŸ”“ get_next_position_id()
       âš ï¸  NO DOCSTRING

    ğŸ”“ open_position()
       Docstring:
         Open new position.
         
         Accepts entry_fee (typically SpreadFee).

    ğŸ”“ close_position_portfolio()
       Docstring:
         Close position and realize P&L.
         
         Accepts exit_fee (commission or final swap).

    ğŸ”“ modify_position()
       Docstring:
         Modify position SL/TP.
         
         NEW METHOD for dynamic position management.
         
         Args:
             position_id: Position to modify
             new_stop_loss: New stop loss (None = no change)
             new_take_profit: New take profit (None = no change)
         
         Returns:
             True if modified successfully

    ğŸ”“ mark_dirty()
       Docstring:
         Mark positions as needing update (LAZY EVALUATION).
         
         Args:
             tick: Current tick data with bid/ask prices

    ğŸ”’ _calculate_tick_value()
       Docstring:
         Calculate tick_value dynamically.
         
         Args:
             symbol_spec: Static symbol specification
             current_price: Current market price
         
         Returns:
             tick_value for P&L calculations

    ğŸ”’ _ensure_positions_updated()
       Docstring:
         Ensure positions are updated with latest prices (LAZY EVALUATION).
         
         Performance:
         - Only updates if _positions_dirty = True
         - Builds symbol specs on-demand (not every tick!)

    ğŸ”“ get_open_positions()
       Docstring:
         Get list of all open positions

    ğŸ”“ get_closed_positions()
       Docstring:
         Get list of all closed positions.
         
         NEW METHOD for order history and performance analysis.

    ğŸ”“ get_position()
       Docstring:
         Get specific position by ID

    ğŸ”“ has_open_positions()
       Docstring:
         Check if any positions are open

    ğŸ”“ get_account_info()
       Docstring:
         Get current account information.
         
         Returns account state including:
         - balance: Total account balance
         - equity: Balance + unrealized P&L
         - margin_used: Margin locked in open positions
         - free_margin: Available margin for new trades
         - margin_level: (equity / margin_used) * 100
         
         Returns:
             AccountInfo dataclass with all account metrics

    ğŸ”“ get_total_trades()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_winning_trades()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_losing_trades()
       âš ï¸  NO DOCSTRING

    ğŸ”’ _calculate_equity()
       Docstring:
         Get current equity (balance + unrealized P&L)

    ğŸ”“ get_free_margin()
       Docstring:
         Get free margin

    ğŸ”“ is_margin_call()
       Docstring:
         Check if margin call

    ğŸ”“ is_stop_out()
       Docstring:
         Check if stop out

    ğŸ”“ get_cost_breakdown()
       Docstring:
         Get breakdown of all trading costs.
         
         Returns immutable copy (safe for external use).
         
         Returns:
             CostBreakdown with total_spread_cost, total_commission, total_swap, total_fees

    ğŸ”’ _update_statistics()
       Docstring:
         Update trading statistics after position close.
         
         Uses direct attributes instead of dict.

    ğŸ”“ get_portfolio_statistics()
       Docstring:
         Get portfolio statistics with fee breakdown.
         
         Creates new PortfolioStats from direct attributes.
         Always returns new object (safe for external use).

    ğŸ”“ reset()
       Docstring:
         Reset portfolio to initial state

================================================================================
class TradeSimulator
  File: framework/trading_env/trade_simulator.py:41

  Class Docstring:
    Trade Simulator - Orchestrates order execution and portfolio.
    
    Uses OrderExecutionEngine for realistic delays (Issue #003).
    Orders go through PENDING â†’ EXECUTED lifecycle.
    
    Uses direct attributes for execution statistics.
    
    CURRENCY HANDLING:
    - Supports "auto" detection: account_currency = symbol quote currency
    - Logs currency operations for transparency

  Methods (24):

    ğŸ”’ __init__()
       Docstring:
         Initialize trade simulator.
         
         Args:
             broker_config: Broker configuration with spreads and capabilities
             initial_balance: Starting account balance
             account_currency: Account currency (or "auto" for symbol-based detection)
             symbol: Trading symbol (required for auto-detection)
             logger: Logger instance
             seeds: Seeds for order execution delays (from config)

    ğŸ”“ update_prices()
       Docstring:
         Update prices and process pending orders (OPTIMIZED).
         
         Called by BatchOrchestrator on every tick to:
         1. Update current tick data
         2. Process pending orders that are ready to fill
         3. Update portfolio with new tick (LAZY - no specs overhead!)
         
         Args:
             tick: Current tick data with bid/ask prices
         
         Performance Optimization:
         - BEFORE: Built symbol_specs + tick_values every tick (99.8% wasted)
         - AFTER: Just pass tick to portfolio (500Ã— faster!)
         - Portfolio builds specs only when needed (get_account_info, close_position)

    ğŸ”“ get_current_price()
       Docstring:
         Get current bid/ask price for symbol.
         
         Returns:
             (bid, ask) tuple

    ğŸ”“ open_order_with_latency()
       Docstring:
         Send order to broker simulation.
         
         Automatically attaches SpreadFee from live tick data.
         Uses direct attributes for stats.

    ğŸ”’ _check_and_open_order_in_portfolio()
       Docstring:
         Fill pending_order OPEN order (after delay).
         
         Called by update_prices when order ready.
         Creates position in portfolio.
         
         Args:
             pending_order: PendingOrder with order_action=PendingOrderAction.OPEN

    ğŸ”’ _execute_limit_order()
       Docstring:
         Execute limit order.
         
         MVP: Not implemented yet.

    ğŸ”“ modify_position()
       Docstring:
         Modify position SL/TP.
         
         NEW METHOD for dynamic position management.
         
         Args:
             position_id: Position to modify
             new_stop_loss: New SL (None = no change)
             new_take_profit: New TP (None = no change)
         
         Returns:
             True if modified successfully
         
         Example:
             # Trailing stop
             position = trading_env.get_position("pos_1")
             if tick.bid > position.entry_price + 0.0050:
                 trading_env.modify_position(
                     position_id="pos_1",
                     new_stop_loss=position.entry_price + 0.0020
                 )

    ğŸ”“ close_position_with_latency()
       Docstring:
         Submit close position order with delay.
         
         Position will be closed after realistic broker latency.
         
         Args:
             position_id: Position to close
             lots: Lots to close (None = close all)
         
         Returns:
             OrderResult with PENDING status

    ğŸ”’ _close_and_fill_order_in_portfolio()
       Docstring:
         Fill pending_order CLOSE order (after delay).
         
         Called by update_prices when close order ready.
         Closes position in portfolio.
         
         Args:
             pending_order: PendingOrder with order_action=PendingOrderAction.CLOSE

    ğŸ”“ close_all_remaining_orders()
       Docstring:
         BEFORE collecting statistics - cleanup pending_order orders

    ğŸ”“ get_account_info()
       Docstring:
         Get current account information.
         
         Returns copy (safe for external use).

    ğŸ”“ get_open_positions()
       Docstring:
         Get all ACTIVE positions (real + pending OPENs, excluding pending CLOSEs).
         
         Decision Logic sees unified view:
         - Real positions from Portfolio
         - Pending OPEN orders as pseudo-positions (pending=True)
         - Excludes positions with pending CLOSE orders
         
         This hides latency simulation details from Decision Logic.
         
         Returns:
             List of Position objects (mix of real and pseudo-positions)

    ğŸ”“ get_position()
       Docstring:
         Get specific position by ID

    ğŸ”“ get_balance()
       Docstring:
         Get account balance

    ğŸ”“ get_free_margin()
       Docstring:
         Get free margin

    ğŸ”’ _calculate_tick_value()
       Docstring:
         Calculate tick_value dynamically based on account currency and current price.
         
         tick_value represents the value of 1 point movement at 1 standard lot
         in the account currency.
         
         Calculation Logic:
         - If Account Currency == Quote Currency: tick_value = 1.0 (no conversion)
         - If Account Currency == Base Currency: tick_value = 1.0 / current_price
         - Cross Currency: Not supported in MVP (raises NotImplementedError)
         
         Args:
             symbol_spec: Static symbol specification
             current_price: Current market price (mid/bid/ask)
         
         Returns:
             tick_value for P&L calculations
         
         Raises:
             NotImplementedError: If cross-currency conversion needed
         
         Example:
             GBPUSD with Account=USD:
             â†’ tick_value = 1.0 (Quote matches Account)
         
             GBPUSD with Account=GBP:
             â†’ tick_value = 1.0 / 1.33000 = 0.7519
         
             GBPUSD with Account=JPY:
             â†’ NotImplementedError (needs USDJPY rate)

    ğŸ”“ get_order_history()
       Docstring:
         Get complete order history.
         
         NEW METHOD for performance analysis and debugging.
         
         Returns:
             List of all OrderResults (executed and rejected)
         
         Example:
             history = trading_env.get_order_history()
         
             executed = [o for o in history if o.is_success]
             rejected = [o for o in history if o.is_rejected]
         
             vLog.info(f"Total orders: {len(history)}")
             vLog.info(f"Executed: {len(executed)}")
             vLog.info(f"Rejected: {len(rejected)}")

    ğŸ”“ get_closed_positions()
       Docstring:
         Get all closed positions.
         
         NEW METHOD for performance reports and P&L analysis.
         
         Returns:
             List of closed Position objects with full fee breakdown
         
         Example:
             closed = trading_env.get_closed_positions()
         
             for pos in closed:
                 vLog.info(f"Position {pos.position_id}:")
                 vLog.info(f"  P&L: {pos.unrealized_pnl:.2f}")
                 vLog.info(f"  Spread: {pos.get_spread_cost():.2f}")
                 vLog.info(f"  Duration: {pos.close_time - pos.entry_time}")

    ğŸ”“ get_broker_name()
       Docstring:
         Get broker name

    ğŸ”“ get_broker_capabilities()
       Docstring:
         Get broker order capabilities

    ğŸ”“ get_symbol_spec()
       Docstring:
         Get symbol specifications

    ğŸ”“ get_execution_stats()
       Docstring:
         Get order execution statistics.
         
         Creates new ExecutionStats from direct attributes.
         Always returns new object (safe for external use).

    ğŸ”“ reset()
       Docstring:
         Reset simulator to initial state

    ğŸ”“ get_tick_counter()
       âš ï¸  NO DOCSTRING

================================================================================
class FeeType
  Inherits from: Enum
  File: framework/trading_env/trading_fees.py:24

  Class Docstring:
    Trading fee type classification

================================================================================
class FeeStatus
  Inherits from: Enum
  File: framework/trading_env/trading_fees.py:32

  Class Docstring:
    Fee payment status

================================================================================
class AbstractTradingFee
  Inherits from: ABC
  Decorators: dataclass
  File: framework/trading_env/trading_fees.py:40

  Class Docstring:
    Abstract base class for all trading fees.
    
    All fee types inherit from this and implement calculate_cost().
    Fees are attached to positions and accumulated over the position lifecycle.
    
    Polymorphic design allows different brokers to use different fee models
    without changing the Position or Portfolio code.

  Methods (4):

    ğŸ”’ __post_init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ calculate_cost()
       Docstring:
         Calculate fee cost in account currency.
         
         Implementation varies by fee type.
         Returns absolute cost (always positive, even if swap is credit).

    ğŸ”“ apply()
       Docstring:
         Mark fee as applied to balance

    ğŸ”“ get_display_name()
       Docstring:
         Get human-readable fee name

================================================================================
class SpreadFee
  Inherits from: AbstractTradingFee
  Decorators: dataclass
  File: framework/trading_env/trading_fees.py:88

  Class Docstring:
    Spread Fee - Implicit cost from bid/ask difference.
    
    FULLY IMPLEMENTED - Calculated from LIVE tick data at order entry.
    
    Calculation:
        spread_points = (ask - bid) * (10 ** digits)
        cost = spread_points * tick_value * lots
    
    Example (EURUSD):
        bid = 1.17408, ask = 1.17433
        spread = 0.00025 (2.5 pips)
        digits = 5
        spread_points = 0.00025 * 100000 = 25 points
        cost = 25 * 0.85155 * 0.1 = 2.13 EUR

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize spread fee from live tick data.
         
         Args:
             bid: Current bid price
             ask: Current ask price
             lots: Order size
             tick_value: Value per tick per lot
             digits: Symbol decimal places
             timestamp: Fee timestamp (defaults to now)

    ğŸ”“ calculate_cost()
       Docstring:
         Calculate spread cost.
         
         Formula:
             spread_points = (ask - bid) * (10^digits)
             cost = spread_points * tick_value * lots
         
         Returns:
             Spread cost in account currency

================================================================================
class SwapFee
  Inherits from: AbstractTradingFee
  Decorators: dataclass
  File: framework/trading_env/trading_fees.py:176

  Class Docstring:
    Swap Fee - Overnight interest for holding positions.
    
    PREPARED - Calculation deferred to Post-MVP.
    
    Accumulates daily at broker rollover time (usually 00:00 server time).
    Can be positive (credit) or negative (debit) depending on interest differential.
    
    Future Implementation:
        - Check if position held overnight
        - Apply swap_long or swap_short from broker config
        - Accumulate daily until position closed
        - Triple swap on Wednesdays (rollover for weekend)
    
    Example (EURUSD from JSON):
        swap_long: -8.75 points (you pay)
        swap_short: 4.34 points (you receive)
    
        Long position held 3 nights:
        cost = -8.75 * 3 * tick_value * lots = -22.31 EUR (debit)

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize swap fee (calculation deferred).
         
         Args:
             swap_rate_points: Swap rate from broker config
             days_held: Number of overnight holds
             tick_value: Value per tick per lot
             lots: Position size
             timestamp: Fee timestamp

    ğŸ”“ calculate_cost()
       Docstring:
         Calculate swap cost (deferred).
         
         Post-MVP Implementation:
             cost = swap_rate_points * days_held * tick_value * lots
         
         Returns:
             0.0 (deferred to Post-MVP)

================================================================================
class CommissionFee
  Inherits from: AbstractTradingFee
  Decorators: dataclass
  File: framework/trading_env/trading_fees.py:260

  Class Docstring:
    Commission Fee - Explicit broker commission.
    
    PREPARED - Calculation deferred to Post-MVP.
    
    Common in ECN brokers (e.g., IC Markets charges $7 per lot).
    Can be per-lot or percentage-based.
    
    Types:
    - Per Lot: Fixed amount per lot (e.g., $7/lot)
    - Percentage: Percentage of order value (e.g., 0.1%)
    - Per Side: Charged on entry, exit, or both
    
    Future Implementation:
        - Read commission config from broker JSON
        - Apply on order entry and/or close
        - Track total commission separately
    
    Example:
        IC Markets ECN: $7 per lot
        Order: 0.5 lots EURUSD
        Commission = 7 * 0.5 = $3.50 (entry) + $3.50 (exit) = $7 total

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize commission fee (calculation deferred).
         
         Args:
             commission_mode: "per_lot" or "percentage"
             commission_rate: Commission amount or percentage
             lots: Order size
             order_value: Order value in account currency (for percentage)
             side: "entry", "exit", or "both"
             timestamp: Fee timestamp

    ğŸ”“ calculate_cost()
       Docstring:
         Calculate commission (deferred).
         
         Post-MVP Implementation:
             if mode == "per_lot":
                 cost = commission_rate * lots
             elif mode == "percentage":
                 cost = order_value * (commission_rate / 100)
         
         Returns:
             0.0 (deferred to Post-MVP)

================================================================================
class MakerTakerFee
  Inherits from: AbstractTradingFee
  Decorators: dataclass
  File: framework/trading_env/trading_fees.py:352

  Class Docstring:
    Maker/Taker Fee - Crypto exchange fee model.
    
    PREPARED - Calculation deferred to Post-MVP.
    
    Maker: Adds liquidity (limit orders) - lower fee
    Taker: Removes liquidity (market orders) - higher fee
    
    Common in crypto exchanges (Kraken, Binance, Coinbase).
    Fees are percentage-based on order value.
    
    Future Implementation:
        - Detect if order is maker or taker
        - Read maker_fee / taker_fee from broker config
        - Calculate as percentage of order value
    
    Example (Kraken from dummy config):
        maker_fee: 0.16%
        taker_fee: 0.26%
    
        Market buy 1 BTC @ $60,000:
        cost = 60000 * 0.0026 = $156

  Methods (2):

    ğŸ”’ __init__()
       Docstring:
         Initialize maker/taker fee (calculation deferred).
         
         Args:
             is_maker: True if maker order, False if taker
             maker_rate: Maker fee percentage
             taker_rate: Taker fee percentage
             order_value: Order value in account currency
             timestamp: Fee timestamp

    ğŸ”“ calculate_cost()
       Docstring:
         Calculate maker/taker fee (deferred).
         
         Post-MVP Implementation:
             rate = maker_rate if is_maker else taker_rate
             cost = order_value * (rate / 100)
         
         Returns:
             0.0 (deferred to Post-MVP)

================================================================================
class BatchExecutionSummary
  Decorators: dataclass
  File: framework/types/batch_execution_types.py:10

  Class Docstring:
    Summary of batch execution results.
    Broker config loaded once in main process
    Used by BrokerSummary for report generation (no redundant loading)
    broker_config: Any = None  # BrokerConfig instance

================================================================================
class SwapMode
  Inherits from: Enum
  File: framework/types/broker_types.py:19

  Class Docstring:
    Swap calculation mode for overnight positions

================================================================================
class MarginMode
  Inherits from: Enum
  File: framework/types/broker_types.py:27

  Class Docstring:
    Account margin calculation mode

================================================================================
class SymbolSpecification
  Decorators: dataclass(...)
  File: framework/types/broker_types.py:35

  Class Docstring:
    Static symbol specifications (unchanging properties).
    
    These properties are loaded from broker config and represent
    the trading rules and characteristics of a symbol.
    
    DOES NOT include dynamic market data:
    - NO tick_value (currency conversion rate - changes with market)
    - NO bid/ask prices (real-time market data)
    - NO spread_current (real-time spread)
    
    Use Cases:
    - Order validation (min/max lots, tick size)
    - Margin calculation (contract size, leverage)
    - Price formatting (digits)
    - Currency extraction (base/quote for tick_value calculation)

  Methods (4):

    ğŸ”“ get_min_stop_distance()
       Docstring:
         Get minimum SL/TP distance in price units

    ğŸ”“ get_freeze_distance()
       Docstring:
         Get freeze distance in price units

    ğŸ”“ validate_lot_size()
       Docstring:
         Validate lot size against symbol limits.
         
         Returns:
             (is_valid, error_message)

    ğŸ”“ format_price()
       Docstring:
         Format price with correct decimal places

================================================================================
class BrokerSpecification
  Decorators: dataclass(...)
  File: framework/types/broker_types.py:125

  Class Docstring:
    Static broker specifications (unchanging properties).
    
    Represents broker-level configuration like leverage, margin requirements,
    and trading permissions.
    
    Use Cases:
    - Margin calculation (leverage)
    - Risk management (margin call/stopout levels)
    - Order validation (order type support, hedging rules)

  Methods (4):

    ğŸ”“ get_margin_call_ratio()
       Docstring:
         Get margin call level as ratio (e.g., 50% â†’ 0.5)

    ğŸ”“ get_stopout_ratio()
       Docstring:
         Get stopout level as ratio (e.g., 20% â†’ 0.2)

    ğŸ”“ is_demo_account()
       Docstring:
         Check if this is a demo account

    ğŸ”“ is_real_account()
       Docstring:
         Check if this is a real account

================================================================================
class GapCategory
  Inherits from: Enum
  File: framework/types/coverage_report_types.py:8

  Class Docstring:
    Gap classification categories

================================================================================
class IndexEntry
  Decorators: dataclass
  File: framework/types/coverage_report_types.py:18

  Class Docstring:
    Represents a single Parquet file in the index.

================================================================================
class Gap
  Decorators: dataclass
  File: framework/types/coverage_report_types.py:34

  Class Docstring:
    Represents a time gap between two files.

  Methods (3):

    ğŸ”“ gap_hours()
       Docstring:
         Gap duration in hours

    ğŸ”“ duration_human()
       Docstring:
         Human-readable duration

    ğŸ”“ severity_icon()
       Docstring:
         Icon based on severity

================================================================================
class DecisionLogicAction
  Inherits from: Enum
  File: framework/types/decision_logic_types.py:14

  Class Docstring:
    Trading action signals from DecisionLogic.
    
    These are decision-level signals that MAY be converted to orders.
    Not all actions result in orders (e.g. FLAT = no action).
    
    Currently implemented:
    - BUY: Open long position
    - SELL: Open short position
    - FLAT: No action / close position
    
    Future actions (not yet implemented):
    - LIMITBUY: Buy with limit order
    - LIMITSELL: Sell with limit order
    - REDUCE: Reduce position size
    - CLOSE: Explicit close signal

  Methods (1):

    ğŸ”’ __str__()
       Docstring:
         String representation returns the enum value

================================================================================
class DecisionLogicStatistics
  Decorators: dataclass
  File: framework/types/decision_logic_types.py:42

  Class Docstring:
    Statistics tracking for DecisionLogic performance.
    
    Tracks decision-making and order execution metrics.
    Replaces dict-based statistics for type safety.

================================================================================
class Decision
  Decorators: dataclass
  File: framework/types/decision_logic_types.py:58

  Class Docstring:
    Trading decision output from DecisionLogic.
    
    Structured output that replaces dict-based decision format.
    DecisionLogic.compute() returns this to orchestrator.
    
    CHANGE: action is now DecisionLogicAction enum instead of str.

  Methods (1):

    ğŸ”“ to_dict()
       Docstring:
         Convert to dict with enum as string value for JSON serialization

================================================================================
class PendingOrderAction
  Inherits from: Enum
  File: framework/types/latency_simulator_types.py:18

  Class Docstring:
    Order type classification.
    
    Common (Tier 1): MARKET, LIMIT
    Extended (Tier 2): STOP, STOP_LIMIT, TRAILING_STOP, ICEBERG

  Methods (1):

    ğŸ”’ __str__()
       Docstring:
         String representation returns the enum value

================================================================================
class PendingOrder
  Decorators: dataclass
  File: framework/types/latency_simulator_types.py:34

  Class Docstring:
    Order waiting to be filled (open or close).
    
    Contains all information needed to execute the order once
    the delay period has elapsed.

  Methods (1):

    ğŸ”“ to_dict()
       âš ï¸  NO DOCSTRING

================================================================================
class LiveScenarioStats
  Decorators: dataclass
  File: framework/types/live_scenario_stats_types.py:19

  Class Docstring:
    Real-time statistics for a running scenario.
    
    Two-tier system:
    - Basic Mode: Essential progress + portfolio basics
    - Detailed Mode: Includes full PortfolioStats object
    
    Attributes:
        scenario_name: Name of the scenario
        symbol: Trading symbol (e.g., "EURUSD")
        scenario_index: Index in scenario list
        total_ticks: Total number of ticks to process
        ticks_processed: Number of ticks processed so far
        progress_percent: Completion percentage (0-100)
        status: Execution status (ScenarioStatus enum)
        first_tick_time: ISO timestamp of first tick
        current_tick_time: ISO timestamp of current tick
        tick_timespan_seconds: Elapsed simulation time
        current_balance: Current portfolio balance
        initial_balance: Starting portfolio balance
        total_trades: Total number of trades executed
        winning_trades: Number of winning trades
        losing_trades: Number of losing trades
        portfolio_dirty_flag: Dirty flag for lazy evaluation transparency
        portfolio_stats: Full PortfolioStats (optional, detailed mode only)

================================================================================
class ProcessLiveSetup
  Decorators: dataclass
  File: framework/types/live_stats_config_types.py:10

  Class Docstring:
    Config initialization for live view

================================================================================
class ScenarioStatus
  Inherits from: Enum
  File: framework/types/live_stats_config_types.py:22

  Class Docstring:
    Live scenario execution states.
    
    Flow (BatchOrchestrator level):
        INITIALIZED â†’ WARMUP_DATA_TICKS â†’ WARMUP_DATA_BARS â†’ WARMUP_TRADER â†’ [Submit to Pool]
    
    Flow (Subprocess level):
        INIT_PROCESS â†’ RUNNING â†’ COMPLETED
    
    States:
        INITIALIZED: Scenario object created (BatchOrchestrator)
        WARMUP_COVERAGE: Loading Gap Report, Data Coverage for execution validation
        WARMUP_DATA_TICKS: Loading ticks (BatchOrchestrator, Phase 1)
        WARMUP_DATA_BARS: Loading bars (BatchOrchestrator, Phase 1)
        WARMUP_TRADER: Loading broker config (BatchOrchestrator, Phase 1)
        INIT_PROCESS: Process started, initializing objects (Subprocess)
        RUNNING: Tick loop running (Subprocess)
        COMPLETED: Tick loop finished successfully (Subprocess)
        FINISHED_WITH_ERROR: Error during init or run (Subprocess)

================================================================================
class LiveStatsExportConfig
  Decorators: dataclass
  File: framework/types/live_stats_config_types.py:58

  Class Docstring:
    Configuration for live stats exports.
    
    Serializable config passed to subprocesses.
    Controls which data is exported via queue.
    
    Args:
        enabled: Master switch for monitoring
        detailed_mode: Basic vs. Detailed mode
        export_portfolio_stats: Include full PortfolioStats
        export_performance_stats: Include BatchPerformanceStats
        export_current_bars: Include current M5, M30, etc.
        update_interval_sec: Time between updates (from tui_refresh_rate_ms)

  Methods (1):

    ğŸ”“ from_app_config()
       Docstring:
         Create config from app_config with threshold logic.
         
         Args:
             app_config: Application configuration
             scenario_count: Number of scenarios in batch
         
         Returns:
             LiveStatsExportConfig with resolved settings

================================================================================
class ColorCodes
  File: framework/types/log_level.py:17

  Class Docstring:
    ANSI Color Codes for console output

================================================================================
class LogLevel
  File: framework/types/log_level.py:29

  Class Docstring:
    Log level definitions and validation.
    Thread-safe, case-insensitive validation.

  Methods (3):

    ğŸ”“ validate()
       Docstring:
         Validate and normalize log level (case insensitive).
         
         Args:
             level: Log level string (any case, e.g., "debug", "INFO", "Warning")
         
         Returns:
             Normalized uppercase log level (e.g., "DEBUG", "INFO", "WARNING")
         
         Raises:
             ValueError: If invalid log level

    ğŸ”“ should_log()
       Docstring:
         Check if message should be logged based on configured level.
         
         Messages are logged if their priority >= configured minimum priority.
         
         Args:
             message_level: Level of the message (DEBUG, INFO, WARNING, ERROR)
             configured_level: Configured minimum level
         
         Returns:
             True if message should be logged, False otherwise

    ğŸ”“ get_priority()
       Docstring:
         Get numeric priority for a log level.
         
         Args:
             level: Log level string
         
         Returns:
             Numeric priority (10-40)

================================================================================
class TickData
  Decorators: dataclass
  File: framework/types/market_data_types.py:8

  Class Docstring:
    Tick data structure
    
    PERFORMANCE OPTIMIZED:
    - timestamp is now datetime object instead of string
    - Parsing happens once during data loading, not during bar rendering
    - Expected speedup: 50-70% in bar rendering operations

  Methods (2):

    ğŸ”“ mid()
       Docstring:
         Mid price between bid/ask

    ğŸ”“ to_dict()
       Docstring:
         Convert to dictionary for serialization

================================================================================
class Bar
  Decorators: dataclass
  File: framework/types/market_data_types.py:41

  Class Docstring:
    Standard bar structure for all timeframes

  Methods (2):

    ğŸ”“ ohlc()
       Docstring:
         OHLC tuple

    ğŸ”“ update_with_tick()
       Docstring:
         Update bar with new tick data

================================================================================
class WeekendClosureWindow
  Decorators: dataclass
  File: framework/types/market_types.py:17

  Class Docstring:
    Configuration for weekend market closure detection.
    
    Defines expected timing and duration ranges for normal weekend gaps
    in forex market data (Friday evening â†’ Monday morning).
    
    Attributes:
        friday_start_hour_utc: Hour (UTC) when Friday closure begins (>= this hour)
        sunday_end_hour_utc : Hour (UTC) when Monday open ends (<= this hour)
        min_duration_hours: Minimum expected weekend gap duration
        max_duration_hours: Maximum expected weekend gap duration
        alt_min_duration_hours: Alternative pattern minimum (Saturday â†’ Monday)
        alt_max_duration_hours: Alternative pattern maximum (Saturday â†’ Monday)

  Methods (3):

    ğŸ”“ get_description()
       Docstring:
         Generate human-readable description of closure window.
         
         Returns:
             Formatted multi-line string for reports

    ğŸ”“ matches_primary_pattern()
       Docstring:
         Check if gap matches primary Friday â†’ Monday pattern.
         
         Args:
             start_weekday: Start day (0=Monday, 4=Friday)
             start_hour: Start hour UTC
             end_weekday: End day (0=Monday)
             end_hour: End hour UTC
             gap_hours: Gap duration in hours
         
         Returns:
             True if matches primary weekend pattern

    ğŸ”“ matches_alternative_pattern()
       Docstring:
         Check if gap matches alternative Saturday â†’ Monday pattern.
         
         Args:
             start_weekday: Start day (5=Saturday)
             end_weekday: End day (0=Monday)
             end_hour: End hour UTC
             gap_hours: Gap duration in hours
         
         Returns:
             True if matches alternative weekend pattern

================================================================================
class OrderType
  Inherits from: Enum
  File: framework/types/order_types.py:22

  Class Docstring:
    Order type classification.
    
    Common (Tier 1): MARKET, LIMIT
    Extended (Tier 2): STOP, STOP_LIMIT, TRAILING_STOP, ICEBERG

================================================================================
class OrderDirection
  Inherits from: Enum
  File: framework/types/order_types.py:37

  Class Docstring:
    Order direction (Buy or Sell)

  Methods (1):

    ğŸ”’ __str__()
       Docstring:
         String representation returns the enum value

================================================================================
class OrderStatus
  Inherits from: Enum
  File: framework/types/order_types.py:47

  Class Docstring:
    Order execution status

================================================================================
class RejectionReason
  Inherits from: Enum
  File: framework/types/order_types.py:58

  Class Docstring:
    Reasons why orders get rejected

================================================================================
class OrderCapabilities
  Decorators: dataclass
  File: framework/types/order_types.py:74

  Class Docstring:
    Runtime capability checks for broker-specific order types.
    
    Common capabilities (all brokers):
    - market_orders, limit_orders
    
    Extended capabilities (broker-specific):
    - stop_orders, stop_limit_orders, trailing_stop, iceberg_orders

  Methods (1):

    ğŸ”“ supports_order_type()
       Docstring:
         Check if broker supports specific order type

================================================================================
class BaseOrder
  Decorators: dataclass
  File: framework/types/order_types.py:116

  Class Docstring:
    Base order structure (common fields)

  Methods (1):

    ğŸ”“ validate()
       Docstring:
         Validate lot size against broker limits

================================================================================
class MarketOrder
  Inherits from: BaseOrder
  Decorators: dataclass
  File: framework/types/order_types.py:147

  Class Docstring:
    Market Order - Execute immediately at current market price
    
    Common to ALL brokers (Tier 1)

================================================================================
class LimitOrder
  Inherits from: BaseOrder
  Decorators: dataclass
  File: framework/types/order_types.py:160

  Class Docstring:
    Limit Order - Execute at specified price or better
    
    Common to ALL brokers (Tier 1)

================================================================================
class StopOrder
  Inherits from: BaseOrder
  Decorators: dataclass
  File: framework/types/order_types.py:176

  Class Docstring:
    Stop Order - Becomes market order when price reaches stop level
    
    Extended feature (Tier 2) - MT5: yes, Kraken: no

================================================================================
class StopLimitOrder
  Inherits from: BaseOrder
  Decorators: dataclass
  File: framework/types/order_types.py:189

  Class Docstring:
    Stop-Limit Order - Becomes limit order when stop price reached
    
    Extended feature (Tier 2) - MT5: yes, Kraken: yes

================================================================================
class IcebergOrder
  Inherits from: BaseOrder
  Decorators: dataclass
  File: framework/types/order_types.py:203

  Class Docstring:
    Iceberg Order - Large order split into smaller visible chunks
    
    Extended feature (Tier 2) - MT5: no, Kraken: yes

================================================================================
class OrderResult
  Decorators: dataclass
  File: framework/types/order_types.py:223

  Class Docstring:
    Result of order execution attempt.
    
    Contains execution details, status, and broker feedback.

  Methods (3):

    ğŸ”“ is_success()
       âš ï¸  NO DOCSTRING

    ğŸ”“ is_rejected()
       âš ï¸  NO DOCSTRING

    ğŸ”“ to_dict()
       Docstring:
         Convert to dictionary for serialization

================================================================================
class OperationProfile
  Decorators: dataclass
  File: framework/types/performance_metrics_types.py:21

  Class Docstring:
    Profiling data for a single operation type.
    
    Tracks timing and call counts for operations like:
    - trade_simulator
    - bar_rendering
    - bar_history
    - worker_decision
    - order_execution
    - stats_update

================================================================================
class TickLoopProfile
  Decorators: dataclass
  File: framework/types/performance_metrics_types.py:41

  Class Docstring:
    Complete profiling data for a scenario's tick loop.
    
    Contains:
    - Per-operation breakdowns
    - Total tick processing time
    - Performance percentages
    - Bottleneck identification

  Methods (1):

    ğŸ”’ __post_init__()
       Docstring:
         Calculate derived metrics after initialization.

================================================================================
class ProfilingMetrics
  Decorators: dataclass
  File: framework/types/performance_metrics_types.py:80

  Class Docstring:
    Aggregated profiling metrics across multiple scenarios.
    
    Used for:
    - Cross-scenario performance comparison
    - Identifying consistent bottlenecks
    - Performance optimization targets

  Methods (1):

    ğŸ”“ add_scenario_profile()
       Docstring:
         Add a scenario profile and update aggregates.

================================================================================
class ResourceMetrics
  Decorators: dataclass
  File: framework/types/performance_metrics_types.py:130

  Class Docstring:
    System resource usage during scenario execution.
    
    Optional metrics that can be collected:
    - CPU usage (per core or average)
    - Memory usage (RAM)
    - Thread count
    - I/O statistics

================================================================================
class PerformanceSnapshot
  Decorators: dataclass
  File: framework/types/performance_metrics_types.py:161

  Class Docstring:
    Point-in-time performance snapshot during execution.
    
    Used for:
    - Live progress display
    - Historical performance tracking
    - Performance degradation detection

================================================================================
class WorkerDecisionBreakdown
  Decorators: dataclass
  File: framework/types/performance_metrics_types.py:188

  Class Docstring:
    Detailed breakdown of worker_decision time.
    
    Shows exactly where time is spent in WorkerCoordinator.process_tick():
    - Pure worker computation time
    - Decision logic computation time
    - Coordination overhead (the mystery!)
    
    This helps identify performance bottlenecks within the decision pipeline.

  Methods (1):

    ğŸ”’ __post_init__()
       Docstring:
         Calculate derived metrics after initialization.

================================================================================
class WorkerPerformanceStats
  Decorators: dataclass
  File: framework/types/performance_stats_types.py:20

  Class Docstring:
    Performance statistics for a single worker.
    
    All fields prefixed with 'worker_' for unique searchability.
    
    Attributes:
        worker_type: Worker type (e.g., "CORE/rsi")
        worker_name: Worker instance name (e.g., "RSI_M5")
        worker_call_count: Number of times worker was called
        worker_total_time_ms: Total execution time in milliseconds
        worker_avg_time_ms: Average execution time per call
        worker_min_time_ms: Minimum execution time
        worker_max_time_ms: Maximum execution time

================================================================================
class DecisionLogicPerformanceStats
  Decorators: dataclass
  File: framework/types/performance_stats_types.py:45

  Class Docstring:
    Performance statistics for decision logic.
    
    Logic fields prefixed with 'logic_', decision counts with 'decision_'.
    
    Attributes:
        logic_type: Decision logic type (e.g., "CORE/simple_consensus")
        logic_name: Decision logic instance name (e.g., "SimpleConsensus")
        decision_count: Total number of decisions made
        decision_buy_count: Number of BUY decisions
        decision_sell_count: Number of SELL decisions
        decision_total_time_ms: Total execution time in milliseconds
        decision_avg_time_ms: Average execution time per decision
        decision_min_time_ms: Minimum execution time
        decision_max_time_ms: Maximum execution time

================================================================================
class BatchPerformanceStats
  Decorators: dataclass
  File: framework/types/performance_stats_types.py:74

  Class Docstring:
    Complete performance statistics for a scenario batch execution.
    
    2-LEVEL STRUCTURE: Contains worker stats and decision logic stats.
    Parallel execution metrics are integrated (no nested object).
    
    This is the top-level container returned by WorkerCoordinator.get_statistics()
    and stored in ScenarioPerformanceStats.tick_loop_results.performance_stats.
    
    Attributes:
        scenario_name: Name of the scenario
        ticks_processed: Number of ticks processed
        parallel_mode: Whether workers ran in parallel
    
        # Worker aggregates
        total_workers: Total number of workers
        total_worker_calls: Total calls across all workers
        workers: Dict mapping worker_name to WorkerPerformanceStats
    
        # Parallel execution (integrated, not nested)
        parallel_time_saved_ms: Total time saved by parallel execution
        parallel_avg_saved_per_tick_ms: Average time saved per tick
        parallel_status: Status string ("âœ… Faster", "âš ï¸ Slower", "â‰ˆ Equal")
    
        # Decision logic (integrated, not nested)
        decision_logic: DecisionLogicPerformanceStats or None

================================================================================
class WorkerAggregateData
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:10

  Class Docstring:
    Aggregated worker performance data across scenarios.
    
    Args:
        calls: Total number of worker calls
        total_time: Total execution time in milliseconds
        times: List of average times per scenario for calculating scenario averages

================================================================================
class DecisionAggregateData
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:25

  Class Docstring:
    Aggregated decision logic performance data across scenarios.
    
    Args:
        calls: Total number of decisions made
        total_time: Total execution time in milliseconds
        times: List of average times per scenario for calculating scenario averages

================================================================================
class AggregatedPerformanceStats
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:40

  Class Docstring:
    Complete aggregated performance statistics across all scenarios.
    
    Args:
        total_ticks: Total ticks processed across all scenarios
        total_decisions: Total decisions made across all scenarios
        total_signals: Total signals generated across all scenarios
        worker_aggregates: Worker performance data by worker name
        decision_aggregates: Decision logic performance data

================================================================================
class ScenarioBottleneckData
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:61

  Class Docstring:
    Bottleneck data for slowest scenario.
    
    Args:
        name: Scenario name
        avg_time_per_tick: Average time per tick in milliseconds
        total_time: Total execution time in milliseconds

================================================================================
class WorkerBottleneckData
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:76

  Class Docstring:
    Bottleneck data for slowest worker.
    
    Args:
        name: Worker name
        avg_time: Average execution time in milliseconds
        scenarios: List of (scenario_name, avg_time) tuples

================================================================================
class DecisionLogicBottleneckData
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:91

  Class Docstring:
    Bottleneck data for slowest decision logic.
    
    Args:
        name: Decision logic name
        avg_time: Average execution time in milliseconds
        scenarios: List of (scenario_name, avg_time) tuples

================================================================================
class ParallelBottleneckData
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:106

  Class Docstring:
    Bottleneck data for worst parallel efficiency.
    
    Args:
        name: Scenario name
        time_saved: Time saved (negative means parallel slower than sequential)
        status: Parallel execution status description

================================================================================
class PerformanceBottlenecks
  Decorators: dataclass
  File: framework/types/performance_summary_aggregation_types.py:121

  Class Docstring:
    Complete bottleneck analysis across all scenarios.
    
    Args:
        slowest_scenario: Data for slowest scenario (optional)
        slowest_worker: Data for slowest worker (optional)
        slowest_decision_logic: Data for slowest decision logic (optional)
        worst_parallel: Data for worst parallel efficiency (optional)

================================================================================
class AggregatedPortfolio
  Decorators: dataclass
  File: framework/types/portfolio_aggregation_types.py:17

  Class Docstring:
    Aggregated portfolio statistics for scenarios with same currency.
    
    Groups scenarios by account currency to avoid cross-currency conversion issues.
    Includes time divergence warning for scenarios spanning significant time periods.
    
    Args:
        currency: Account currency (USD, EUR, JPY, etc.)
        scenario_names: List of scenario names in this group
        scenario_count: Number of scenarios aggregated
        portfolio_stats: Aggregated portfolio statistics
        execution_stats: Aggregated order execution statistics
        cost_breakdown: Aggregated cost breakdown
        time_span_days: Days between earliest and latest tick in group
        has_time_divergence_warning: True if time span exceeds threshold

================================================================================
class PositionStatus
  Inherits from: Enum
  File: framework/types/portfolio_types.py:10

  Class Docstring:
    Position status

================================================================================
class Position
  Decorators: dataclass
  File: framework/types/portfolio_types.py:18

  Class Docstring:
    Open trading position with full fee tracking.
    
    Now includes List[AbstractTradingFee] for all costs.

  Methods (9):

    ğŸ”“ update_current_price()
       Docstring:
         Update current price and recalculate unrealized P&L.
         
         P&L calculation includes all accumulated fees.

    ğŸ”“ add_fee()
       Docstring:
         Add fee to position

    ğŸ”“ get_total_fees()
       Docstring:
         Get sum of all fees attached to this position

    ğŸ”“ get_fees_by_type()
       Docstring:
         Get all fees of specific type

    ğŸ”“ get_spread_cost()
       Docstring:
         Get total spread cost

    ğŸ”“ get_commission_cost()
       Docstring:
         Get total commission cost

    ğŸ”“ get_swap_cost()
       Docstring:
         Get total swap cost

    ğŸ”“ get_margin_used()
       Docstring:
         Calculate margin used by this position

    ğŸ”“ is_open()
       Docstring:
         Check if position is still open

================================================================================
class TickRequirement
  Decorators: dataclass
  File: framework/types/process_data_types.py:37

  Class Docstring:
    Tick data requirement for a single scenario.
    
    Supports both tick-limited and timespan modes.

================================================================================
class BarRequirement
  Decorators: dataclass
  File: framework/types/process_data_types.py:53

  Class Docstring:
    Bar data requirement for warmup.
    
    Extracted from worker configurations.

================================================================================
class RequirementsMap
  Decorators: dataclass
  File: framework/types/process_data_types.py:68

  Class Docstring:
    Aggregated requirements from all scenarios.
    
    Used by SharedDataPreparator to load data efficiently.
    Deduplicates overlapping requirements across scenarios.

  Methods (2):

    ğŸ”“ add_tick_requirement()
       Docstring:
         Add tick requirement (deduplication handled in finalize).

    ğŸ”“ add_bar_requirement()
       Docstring:
         Add bar requirement (deduplication handled in finalize).

================================================================================
class ProcessDataPackage
  Decorators: dataclass
  File: framework/types/process_data_types.py:92

  Class Docstring:
    FUNCTIONAL data package for process handover.
    Contains ONLY REQUIRED data - NO unnecessary metadata!
    
    IMMUTABILITY: All collections are tuples for CoW optimization.
    Read-only access in subprocess = 0 memory copy overhead.
    Reminder:
    Python muss die Daten Ã¼ber pickle serialisieren, um sie zwischen Prozessen zu senden. 
    Tuple: Python weiÃŸ "immutable" â†’ kann aggressiver optimieren
    List: Python weiÃŸ "mutabel" â†’ muss defensiver sein beim Pickling
    
    METADATA: Minimal human-readable info for debugging/logging.
    NOT used in processing - only for monitoring.

================================================================================
class ProcessScenarioConfig
  Decorators: dataclass
  File: framework/types/process_data_types.py:139

  Class Docstring:
    Serializable scenario configuration for process execution.
    
    Pure data structure - no complex objects, no locks, no file handles.
    Can be pickled for ProcessPoolExecutor.
    
    Created from SingleScenario + AppConfig in main process.
    
    CORRECTED:
    - strategy_config: Complete config (for create_workers_from_config)
    - scenario_set_name: For logger initialization
    - run_timestamp: Shared across all processes
    - warmup_requirements: REMOVED (validation skipped)
    - account_currency: Changed from 'currency' (supports "auto" detection)

  Methods (1):

    ğŸ”“ from_scenario()
       Docstring:
         Create ProcessScenarioConfig from SingleScenario + AppConfig.
         
         CORRECTED:
         - Uses complete strategy_config (for worker creation)
         - Adds scenario_set_name and run_timestamp
         - Reads 'account_currency' from trade_simulator_config
         
         Args:
             scenario: SingleScenario object
             app_config: Application configuration
             scenario_index: Index in scenario list
             scenario_set_name: Name of scenario set (for logger)
             run_timestamp: Shared timestamp (for logger)
         
         Returns:
             Serializable ProcessScenarioConfig

================================================================================
class ProcessPreparedDataObjects
  Decorators: dataclass
  File: framework/types/process_data_types.py:270

  Class Docstring:
    Prepared Objects from process_startup_preparation
    All those must be created in minimum time

================================================================================
class ProcessProfileData
  Decorators: dataclass
  File: framework/types/process_data_types.py:284

  Class Docstring:
    Profiling from Tick Loop, 
    various profiling points.

================================================================================
class TickRangeStats
  Decorators: dataclass
  File: framework/types/process_data_types.py:294

  Class Docstring:
    Tick time range (internal tick timestamps)

================================================================================
class ProcessTickLoopResult
  Decorators: dataclass
  File: framework/types/process_data_types.py:305

  Class Docstring:
    Result info from Tick Loop, after execution.

================================================================================
class ProcessResult
  Decorators: dataclass
  File: framework/types/process_data_types.py:323

  Class Docstring:
    Result from scenario execution in subprocess.
    
    SERIALIZABLE: All fields are JSON-compatible for later API export.
    Contains everything needed for reports and aggregation.
    
    SUCCESS PATH: Contains complete execution results.
    ERROR PATH: Contains detailed error information.

  Methods (1):

    ğŸ”“ to_dict()
       Docstring:
         Convert to dictionary for serialization.

================================================================================
class BoxRenderConfig
  Decorators: dataclass
  File: framework/types/rendering_types.py:10

  Class Docstring:
    Configuration for box rendering in console output.
    
    Controls box dimensions and grid layout for scenario/portfolio displays.
    
    Attributes:
        box_width: Total box width including borders
        columns: Number of boxes per row in grid layout
        scenario_lines: Content lines for scenario statistics box
        portfolio_lines: Content lines for portfolio statistics box
        column_spacing: Spaces between adjacent boxes in grid

================================================================================
class VolatilityRegime
  Inherits from: Enum
  File: framework/types/scenario_generator_types.py:19

  Class Docstring:
    Volatility regime classification.

  Methods (1):

    ğŸ”’ __str__()
       Docstring:
         String representation returns the enum value

================================================================================
class TradingSession
  Inherits from: Enum
  File: framework/types/scenario_generator_types.py:32

  Class Docstring:
    Trading session identifiers.

  Methods (1):

    ğŸ”’ __str__()
       Docstring:
         String representation returns the enum value

================================================================================
class GenerationStrategy
  Inherits from: Enum
  File: framework/types/scenario_generator_types.py:44

  Class Docstring:
    Scenario generation strategies.

  Methods (1):

    ğŸ”’ __str__()
       Docstring:
         String representation returns the enum value

================================================================================
class PeriodAnalysis
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:60

  Class Docstring:
    Analysis results for a single time period.
    
    Represents one hour of market data with volatility and activity metrics.

================================================================================
class SessionSummary
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:91

  Class Docstring:
    Aggregated statistics for a trading session.

================================================================================
class SymbolAnalysis
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:114

  Class Docstring:
    Complete market analysis for a symbol.

================================================================================
class AnalysisConfig
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:161

  Class Docstring:
    Configuration for market analysis.
    
    Loaded from configs/generator/analysis_config.json

================================================================================
class CrossInstrumentRankingConfig
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:182

  Class Docstring:
    Configuration for cross-instrument comparison ranking.

================================================================================
class BalancedStrategyConfig
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:188

  Class Docstring:
    Configuration for balanced generation strategy.

================================================================================
class BlocksStrategyConfig
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:196

  Class Docstring:
    Configuration for chronological blocks strategy.

================================================================================
class StressStrategyConfig
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:204

  Class Docstring:
    Configuration for stress test strategy.

================================================================================
class GeneratorConfig
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:212

  Class Docstring:
    Complete generator configuration.
    
    Combines analysis config with strategy-specific settings.

  Methods (1):

    ğŸ”“ from_dict()
       Docstring:
         Create config from dictionary (loaded from JSON).
         
         Args:
             data: Configuration dictionary
         
         Returns:
             GeneratorConfig instance

================================================================================
class ScenarioCandidate
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:287

  Class Docstring:
    A candidate time period for scenario generation.
    
    Selected by the generator based on analysis results.

  Methods (1):

    ğŸ”“ to_scenario_dict()
       Docstring:
         Convert to scenario dictionary for config output.
         
         Args:
             name: Scenario name
             max_ticks: Optional tick limit (None = time-based only, no tick limit)
         
         Returns:
             Scenario dictionary compatible with ScenarioConfigSaver

================================================================================
class GenerationResult
  Decorators: dataclass
  File: framework/types/scenario_generator_types.py:343

  Class Docstring:
    Result of scenario generation.

================================================================================
class OperationTiming
  Decorators: dataclass
  File: framework/types/scenario_set_performance_types.py:16

  Class Docstring:
    Timing data for a single operation in tick loop.
    
    Represents profiling data for one operation (e.g., 'worker_decision',
    'bar_rendering') collected during scenario execution.
    
    Attributes:
        total_time_ms: Total time spent in this operation (milliseconds)
        call_count: Number of times this operation was called

  Methods (1):

    ğŸ”“ avg_time_ms()
       Docstring:
         Average time per call.
         
         Returns:
             Average time in milliseconds, or 0.0 if no calls

================================================================================
class ProfilingData
  Decorators: dataclass
  File: framework/types/scenario_set_performance_types.py:42

  Class Docstring:
    Performance profiling data from scenario execution.
    
    Built AFTER tick loop completes (zero overhead during ticks).
    Contains timing for each operation in the tick loop.
    
    Operations tracked:
    - trade_simulator: Price updates
    - bar_rendering: OHLC bar construction
    - bar_history: Historical bar retrieval
    - worker_decision: Worker processing + decision logic
    - order_execution: Order placement and execution
    - stats_update: Statistics updates
    
    Attributes:
        operations: Map of operation_name -> OperationTiming
        total_per_tick_ms: Total time per tick across all operations

  Methods (3):

    ğŸ”“ get_operation_time()
       Docstring:
         Get total time for operation.
         
         Args:
             operation_name: Name of operation (e.g., 'worker_decision')
         
         Returns:
             Total time in milliseconds, or 0.0 if operation not found

    ğŸ”“ get_operation_count()
       Docstring:
         Get call count for operation.
         
         Args:
             operation_name: Name of operation (e.g., 'worker_decision')
         
         Returns:
             Call count, or 0 if operation not found

    ğŸ”“ from_dicts()
       Docstring:
         Build ProfilingData from raw dict data (AFTER loop).
         
         This is called ONCE after tick loop completes.
         Zero overhead during tick processing.
         
         Args:
             profile_times: Map of operation_name -> total_time_ms
             profile_counts: Map of operation_name -> call_count
         
         Returns:
             ProfilingData instance
         
         Example:
             >>> times = {'worker_decision': 123.45, 'bar_rendering': 67.89}
             >>> counts = {'worker_decision': 1000, 'bar_rendering': 1000}
             >>> profiling = ProfilingData.from_dicts(times, counts)

================================================================================
class SingleScenario
  Decorators: dataclass
  File: framework/types/scenario_set_types.py:23

  Class Docstring:
    Test scenario configuration for batch testing

  Methods (3):

    ğŸ”’ __post_init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ to_config_string_for_display()
       Docstring:
         Display string for scenario configuration.
         
         NOTE: Actual config creation is in ProcessScenarioConfig.from_scenario()
         This is just for display/debugging purposes.
         
         Returns:
             Human-readable config summary

    ğŸ”“ is_valid()
       Docstring:
         Check if scenario passed validation.
         
         Returns:
             True if no validation result or validation passed

================================================================================
class LoadedScenarioConfig
  Decorators: dataclass
  File: framework/types/scenario_set_types.py:104

  Class Docstring:
    Result of config loading - raw data before ScenarioSet creation

================================================================================
class ScenarioSet
  File: framework/types/scenario_set_types.py:111

  Class Docstring:
    Self-contained scenario set with its own logging infrastructure

  Methods (4):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ run_timestamp()
       Docstring:
         Expose run_timestamp for easy access

    ğŸ”“ copy_config_snapshot()
       Docstring:
         Copy config snapshot to log directory.
         Call explicitly before execution starts.

    ğŸ”“ write_scenario_system_info_log()
       Docstring:
         Write System Information for Performance Tracking

================================================================================
class BrokerScenarioInfo
  Decorators: dataclass
  File: framework/types/scenario_set_types.py:169

  Class Docstring:
    Internal mapping of broker to scenarios (used for logging).

================================================================================
class ScenarioRequirements
  Decorators: dataclass
  File: framework/types/scenario_types.py:11

  Class Docstring:
    Calculated requirements for a scenario based on its workers.
    
    Each scenario calculates its own requirements independently,
    allowing different scenarios to use completely different
    worker configurations.
    
    Attributes:
        max_warmup_bars: Maximum warmup bars needed across all workers
        all_timeframes: All unique timeframes required by workers
        warmup_by_timeframe: Maximum warmup bars per timeframe
        total_workers: Total number of workers in scenario

================================================================================
class TimeframeConfig
  File: framework/types/timeframe_types.py:16

  Class Docstring:
    Timeframe configuration and utilities
    
    PERFORMANCE OPTIMIZED:
    - Added caching for get_bar_start_time()
    - Same minute always returns same bar start time

  Methods (3):

    ğŸ”“ get_minutes()
       Docstring:
         Get minutes for timeframe

    ğŸ”“ get_bar_start_time()
       Docstring:
         Calculate bar start time for given timestamp.
         
         PERFORMANCE OPTIMIZED:
         - Results are cached per minute
         - Same minute + timeframe always returns cached result
         - Reduces 40,000 calculations to ~few hundred cache lookups

    ğŸ”“ is_bar_complete()
       Docstring:
         Check if bar is complete

================================================================================
class AccountInfo
  Decorators: dataclass
  File: framework/types/trading_env_types.py:19

  Class Docstring:
    Account information snapshot.
    
    Provides real-time account state including balance, equity,
    margin usage, and position statistics.
    
    Attributes:
        balance: Account balance (realized P&L)
        equity: Current equity (balance + unrealized P&L)
        margin_used: Total margin used by open positions
        free_margin: Available margin for new positions
        margin_level: Margin level percentage
        open_positions: Number of open positions
        total_lots: Total lot size across all positions
        currency: Account currency
        leverage: Account leverage

================================================================================
class PortfolioStats
  Decorators: dataclass
  File: framework/types/trading_env_types.py:49

  Class Docstring:
    Complete portfolio performance statistics.
    
    Aggregates trading performance, P&L metrics, and cost breakdown.
    Includes both raw statistics and calculated metrics (win rate, profit factor).
    
    Attributes:
        total_trades: Total number of closed trades
        winning_trades: Number of winning trades
        losing_trades: Number of losing trades
        total_profit: Total profit from winning trades
        total_loss: Total loss from losing trades (absolute value)
        max_drawdown: Maximum equity drawdown
        max_equity: Maximum equity reached
        win_rate: Winning percentage (0.0-1.0)
        profit_factor: Ratio of total profit to total loss
        total_spread_cost: Total spread cost paid
        total_commission: Total commission paid
        total_swap: Total swap paid/received
        total_fees: Sum of all trading costs
        currency: Account currency for all monetary values

================================================================================
class ExecutionStats
  Decorators: dataclass
  File: framework/types/trading_env_types.py:98

  Class Docstring:
    Order execution statistics.
    
    Tracks order submission, execution, and rejection rates.
    Useful for analyzing broker simulation behavior and strategy performance.
    
    Attributes:
        orders_sent: Total orders submitted
        orders_executed: Orders successfully executed
        orders_rejected: Orders rejected (margin, validation, etc.)
        total_commission: Total commission paid on executions
        total_spread_cost: Total spread cost from order fills

================================================================================
class CostBreakdown
  Decorators: dataclass
  File: framework/types/trading_env_types.py:120

  Class Docstring:
    Detailed trading cost breakdown.
    
    Separates trading costs by type for cost analysis and optimization.
    All costs are in account currency.
    
    Attributes:
        total_spread_cost: Bid-ask spread cost (implicit)
        total_commission: Broker commission (explicit)
        total_swap: Overnight interest (can be negative/positive)
        total_fees: Sum of all costs

================================================================================
class ValidationResult
  Decorators: dataclass
  File: framework/types/validation_types.py:11

  Class Docstring:
    Result of scenario validation.
    
    Contains validation status, scenario name, and any errors/warnings.

  Methods (3):

    ğŸ”“ has_errors()
       Docstring:
         Check if validation has errors.

    ğŸ”“ has_warnings()
       Docstring:
         Check if validation has warnings.

    ğŸ”“ get_full_report()
       Docstring:
         Generate detailed error report for invalid scenario.
         
         Returns comprehensive summary of all validation errors
         with actionable information for user.
         
         Returns:
             Multi-line formatted error report

================================================================================
class WorkerState
  Inherits from: Enum
  File: framework/types/worker_types.py:6

  Class Docstring:
    Worker execution states

================================================================================
class WorkerType
  Inherits from: Enum
  File: framework/types/worker_types.py:15

  Class Docstring:
    Worker type classification for monitoring and performance tracking.

================================================================================
class WorkerResult
  Decorators: dataclass
  File: framework/types/worker_types.py:23

  Class Docstring:
    Result from worker computation

================================================================================
class ActivityVolumeProvider
  File: framework/utils/activity_volume_provider.py:15

  Class Docstring:
    Provides unified activity metrics across different market types.
    
    Market Type Mapping:
    - forex_cfd: tick_count (number of price changes)
    - crypto_spot: trade_volume (traded volume in base currency)
    - crypto_futures: trade_volume
    - equity: trade_volume
    
    Usage:
        provider = ActivityVolumeProvider()
        value = provider.get_activity_value(bar_data, 'forex_cfd')
        label = provider.get_metric_label('forex_cfd')

  Methods (8):

    ğŸ”“ get_activity_value()
       Docstring:
         Get primary activity value for given market type.
         
         Args:
             data: Dict containing tick_count and/or trade_volume
             market_type: Market type string
         
         Returns:
             Activity value (tick_count or trade_volume)

    ğŸ”“ get_avg_activity_value()
       Docstring:
         Get average activity value per bar for given market type.
         
         Args:
             data: Dict containing avg_ticks_per_bar and/or avg_volume_per_bar
             market_type: Market type string
         
         Returns:
             Average activity value per bar

    ğŸ”“ get_total_activity_value()
       Docstring:
         Get total activity value for given market type.
         
         Args:
             data: Dict containing total_tick_count and/or total_trade_volume
             market_type: Market type string
         
         Returns:
             Total activity value

    ğŸ”“ get_metric_label()
       Docstring:
         Get human-readable label for the activity metric.
         
         Args:
             market_type: Market type string
         
         Returns:
             Label string (e.g., "Ticks", "Volume")

    ğŸ”“ get_metric_name()
       Docstring:
         Get technical field name for the activity metric.
         
         Args:
             market_type: Market type string
         
         Returns:
             Field name (e.g., "tick_count", "trade_volume")

    ğŸ”“ get_activity_summary()
       Docstring:
         Get complete activity summary for display.
         
         Args:
             data: Dict with activity data
             market_type: Market type string
         
         Returns:
             Tuple of (label, total_value, avg_value)

    ğŸ”“ format_activity_value()
       Docstring:
         Format activity value for display.
         
         Args:
             value: Activity value
             market_type: Market type string
         
         Returns:
             Formatted string

    ğŸ”“ is_volume_based()
       Docstring:
         Check if market type uses trade volume.
         
         Args:
             market_type: Market type string
         
         Returns:
             True if volume-based, False if tick-based

================================================================================
class MarketCalendar
  File: framework/utils/market_calendar.py:17

  Class Docstring:
    Forex market calendar for weekend-aware operations.
    
    Forex market hours: Monday 00:00 UTC - Friday 23:59 UTC
    Closed: Saturday and Sunday
    
    EXTENDED  Added detailed weekend statistics and gap classification

  Methods (10):

    ğŸ”“ get_weekend_closure_description()
       Docstring:
         Get human-readable description of expected weekend closure window.
         
         Returns:
             Formatted multi-line string describing market closure timing

    ğŸ”“ is_market_open()
       Docstring:
         Check if market is open at given timestamp.
         
         Args:
             timestamp: Datetime to check
         
         Returns:
             True if market is open (Monday-Friday), False otherwise

    ğŸ”“ spans_weekend()
       Docstring:
         Check if time period spans a weekend and count weekend days.
         
         Args:
             start: Start timestamp
             end: End timestamp
         
         Returns:
             Tuple of (spans_weekend: bool, weekend_days: int)

    ğŸ”“ validate_timeframe_for_weekends()
       Docstring:
         Validate that timeframe is supported for weekend-aware operations.
         
         Daily and higher timeframes require special weekend handling.
         
         Args:
             timeframe: Timeframe string (e.g., 'M5', 'H1', 'D1')
         
         Raises:
             NotImplementedError: If timeframe requires weekend logic not yet implemented

    ğŸ”“ get_trading_days()
       Docstring:
         Count trading days (Mon-Fri) between two timestamps.
         
         Args:
             start: Start timestamp
             end: End timestamp
         
         Returns:
             Number of trading days in range

    ğŸ”“ get_previous_trading_day()
       Docstring:
         Get the previous trading day from given timestamp.
         Useful for finding Friday when starting on weekend.
         
         Args:
             timestamp: Reference timestamp
         
         Returns:
             Datetime of previous trading day

    ğŸ”“ get_weekend_statistics()
       Docstring:
         Get detailed weekend statistics for a time range.
         
          from TickDataAnalyzer._count_weekends() for central location.
         
         Args:
             start: Start timestamp
             end: End timestamp
         
         Returns:
             Dict with detailed weekend statistics:
             {
                 'full_weekends': int,
                 'saturdays': int,
                 'sundays': int,
                 'total_weekend_days': int,
                 'start_is_weekend': bool,
                 'end_is_weekend': bool,
                 'weekend_percentage': float
             }

    ğŸ”“ classify_gap()
       Docstring:
         Classify a time gap between two timestamps.
         
         Used for data continuity validation and gap analysis.
         
         Args:
             start: Gap start timestamp (end of first file)
             end: Gap end timestamp (start of second file)
             gap_seconds: Gap duration in seconds
         
         Returns:
             Tuple of (GapCategory, reason_string)
         
         Categories:
             - SEAMLESS: < 5 seconds (perfect continuity)
             - WEEKEND: Fr evening â†’ Mo morning, 40-80 hours
             - SHORT: 5s - 30min (connection blip, restart)
             - MODERATE: 30min - 4h (potential data loss)
             - LARGE: > 4h (significant data loss)

    ğŸ”“ format_time_range()
       Docstring:
         Format time range in human-readable format.
         Shows date only once if both timestamps are on the same day.
         
         Args:
             start: Start datetime
             end: End datetime
             date_format: Date format (default: DD.MM.YYYY)
             time_format: Time format (default: HH:MM:SS)
             timezone: Timezone for display (default: UTC)
         
         Returns:
             Formatted string like "23.09.2025 10:30:00 â†’ 13:00:00"
             or "23.09.2025 23:30:00 â†’ 24.09.2025 01:00:00" for different days
         
         Examples:
             >>> start = datetime(2025, 9, 23, 10, 30, 0, tzinfo=pytz.UTC)
             >>> end = datetime(2025, 9, 23, 13, 0, 0, tzinfo=pytz.UTC)
             >>> format_time_range(start, end)
             '23.09.2025 10:30:00 â†’ 13:00:00'

    ğŸ”“ format_time_range_short()
       Docstring:
         Shortened version without seconds: '23.09.2025 10:30 â†’ 13:00'

================================================================================
class ParameterOverrideDetector
  File: framework/utils/parameter_override_detector.py:29

  Class Docstring:
    Central parameter override detection and extraction.
    
    Provides three key functions:
    1. detect_overrides() - Find all differences (for warnings)
    2. format_overrides_for_display() - Pretty print
    3. extract_overrides_for_save() - Get only overrides (for save_config)
    
    This centralizes all override logic that was scattered across config_loader.

  Methods (6):

    ğŸ”“ detect_overrides()
       Docstring:
         Recursively detect parameter overrides between global and scenario configs.
         
         Used in load_config() to warn about parameter changes.
         
         Args:
             global_config: Global configuration dict
             scenario_config: Scenario-specific configuration dict
             path_prefix: Current path in nested dict (for display)
         
         Returns:
             List of tuples: (parameter_path, global_value, scenario_value)
         
         Example:
             overrides = detect_overrides(
                 {"workers": {"CORE/rsi": {"period": 14}}},
                 {"workers": {"CORE/rsi": {"period": 5}}}
             )
             # Returns: [("workers.CORE/rsi.period", 14, 5)]

    ğŸ”“ format_overrides_for_display()
       Docstring:
         Format overrides for log display.
         
         Converts raw override tuples into human-readable strings.
         
         Args:
             overrides: List of override tuples from detect_overrides()
         
         Returns:
             Dict mapping parameter paths to formatted strings
         
         Example:
             formatted = format_overrides_for_display([
                 ("workers.CORE/rsi.period", 14, 5)
             ])
             # Returns: {"workers.CORE/rsi.period": "14 â†’ 5"}

    ğŸ”“ extract_overrides_for_save()
       Docstring:
         Extract ONLY the overrides from scenario config for saving.
         
         This is the KEY function that replaces all manual override loops
         in save_config(). It returns a dict containing ONLY parameters
         that differ from global config.
         
         Args:
             global_config: Global configuration dict
             scenario_config: Scenario-specific configuration dict
             sections: List of section keys to check (e.g., ['workers', 'decision_logic_config'])
         
         Returns:
             Dict with ONLY overridden parameters
         
         Example:
             # Global: {"workers": {"CORE/rsi": {"period": 14, "timeframe": "M5"}}}
             # Scenario: {"workers": {"CORE/rsi": {"period": 5, "timeframe": "M5"}}}
         
             overrides = extract_overrides_for_save(
                 global_config={'workers': {'CORE/rsi': {'period': 14, 'timeframe': 'M5'}}},
                 scenario_config={'workers': {'CORE/rsi': {'period': 5, 'timeframe': 'M5'}}},
                 sections=['workers']
             )
             # Returns: {'workers': {'CORE/rsi': {'period': 5}}}  # Only period changed!

    ğŸ”’ _check_dict_overrides()
       Docstring:
         Recursively check for overrides in nested dictionaries.
         
         Used by detect_overrides() for warning generation.
         
         Args:
             global_dict: Global dict values
             scenario_dict: Scenario dict values
             path: Current path for display
         
         Returns:
             List of override tuples

    ğŸ”’ _extract_dict_overrides()
       Docstring:
         Extract ONLY overridden parameters from nested dicts.
         
         Used by extract_overrides_for_save() for save_config().
         
         This is the workhorse function that replaces all manual
         for loops in save_config().
         
         Args:
             global_dict: Global dict values
             scenario_dict: Scenario dict values
         
         Returns:
             Dict containing ONLY overridden values
         
         Example:
             global_dict = {
                 "CORE/rsi": {"period": 14, "timeframe": "M5"},
                 "CORE/envelope": {"period": 20}
             }
             scenario_dict = {
                 "CORE/rsi": {"period": 5, "timeframe": "M5"},
                 "CORE/envelope": {"period": 20}
             }
         
             result = _extract_dict_overrides(global_dict, scenario_dict)
             # Returns: {"CORE/rsi": {"period": 5}}
             # Note: CORE/envelope is completely omitted (no changes)
             # Note: timeframe is omitted (same as global)

    ğŸ”“ detect_and_log_overrides()
       Docstring:
         Detect and log all parameter overrides for a scenario.
         
         This is a convenience function that:
         1. Checks all config sections (strategy, execution, trade_simulator)
         2. Collects all overrides
         3. Logs warnings if enabled
         4. Returns all overrides for further processing
         
         Use this in load_config() to centralize override detection.
         
         Args:
             scenario_name: Name of the scenario (for logging)
             global_strategy: Global strategy_config
             global_execution: Global execution_config
             global_trade_simulator: Global trade_simulator_config
             scenario_strategy: Scenario's strategy_config (may be empty)
             scenario_execution: Scenario's execution_config (may be empty)
             scenario_trade_simulator: Scenario's trade_simulator_config (may be empty)
             logger: Logger instance (e.g., vLog)
             warn_on_override: Whether to log warnings (from app_config)
         
         Returns:
             List of all override tuples (for further processing if needed)
         
         Example:
             overrides = ParameterOverrideDetector.detect_and_log_overrides(
                 scenario_name="EURUSD_window_02",
                 global_strategy=global_strategy,
                 global_execution=global_execution,
                 global_trade_simulator=global_trade_simulator,
                 scenario_strategy=scenario_data.get('strategy_config', {}),
                 scenario_execution=scenario_data.get('execution_config', {}),
                 scenario_trade_simulator=scenario_data.get('trade_simulator_config', {}),
                 logger=vLog,
                 warn_on_override=True
             )

================================================================================
class ScenarioSetUtils
  File: framework/utils/scenario_set_utils.py:13

  âš ï¸  NO CLASS DOCSTRING

  Methods (2):

    ğŸ”’ __init__()
       âš ï¸  NO DOCSTRING

    ğŸ”“ copy_config_snapshot()
       Docstring:
         Copy scenario config file as snapshot (global only).

================================================================================
class ScenarioDataValidator
  File: framework/validators/scenario_data_validator.py:22

  Class Docstring:
    Validates scenarios against data quality requirements.
    
    Two-stage validation:
    1. Pre-load: Basic checks (start_date not in gap)
    2. Post-load: Quality checks (tick stretch, warmup quality)
    
    Configuration via app_config:
    - warmup_quality_mode: 'permissive' or 'standard'
    - allowed_gap_categories: List of allowed gap types

  Methods (9):

    ğŸ”’ __init__()
       Docstring:
         Initialize validator.
         
         Args:
             coverage_reports: Dict mapping symbol to CoverageReport
             app_config: Application config manager
             logger: Logger instance

    ğŸ”’ _load_allowed_gap_categories()
       Docstring:
         Load allowed gap categories from config.
         
         Returns:
             List of allowed GapCategory enums

    ğŸ”’ _ensure_utc_aware()
       Docstring:
         Ensure datetime is UTC-aware.
         
         Project policy: All datetimes must be UTC-aware.
         
         Args:
             dt: Datetime object (naive or aware)
         
         Returns:
             UTC-aware datetime

    ğŸ”“ validate_loaded_data()
       Docstring:
         Validate scenarios after data has been loaded.
         
         Checks:
         1. start_date not in gap
         2. Tick stretch (first_tick â†’ last_tick) free of forbidden gaps
         3. Warmup bars quality (no synthetic in standard mode)
         
         Args:
             scenarios: List of scenarios to validate
             shared_data: Loaded tick and bar data
             requirements_map: Requirements map for warmup info
         
         Returns:
             Tuple of (valid_scenarios, invalid_scenarios_with_results)

    ğŸ”’ _validate_single_scenario()
       Docstring:
         Validate a single scenario.
         
         Args:
             scenario: Scenario to validate
             shared_data: Loaded data package
             requirements_map: Requirements map
         
         Returns:
             ValidationResult with errors and warnings

    ğŸ”’ _validate_start_date_not_in_gap()
       Docstring:
         Validate that start_date is not inside a gap.
         
         Args:
             scenario: Scenario to validate
             report: Coverage report for symbol
         
         Returns:
             List of error messages (empty if valid)

    ğŸ”’ _validate_tick_stretch()
       Docstring:
         Validate that tick stretch is free of forbidden gaps.
         
         Args:
             scenario: Scenario to validate
             report: Coverage report for symbol
             shared_data: Loaded data package
         
         Returns:
             List of error messages (empty if valid)

    ğŸ”’ _validate_warmup_quality()
       Docstring:
         Validate warmup bar quality based on warmup_quality_mode.
         
         Args:
             scenario: Scenario to validate
             shared_data: Loaded data package
             requirements_map: Requirements map with bar requirements
         
         Returns:
             Tuple of (errors, warnings)

    ğŸ”’ _parse_datetime()
       Docstring:
         Parse datetime string to UTC-aware datetime object.
         
         Args:
             dt_str: Datetime string (ISO format)
         
         Returns:
             UTC-aware datetime object

================================================================================
class ScenarioValidator
  File: framework/validators/scenario_validator.py:19

  Class Docstring:
    Validates scenario set consistency.
    
    MVP: Enforces single quote currency across all scenarios.
    Post-MVP: Will support multi-currency with conversion rates.

  Methods (2):

    ğŸ”“ detect_quote_currency()
       Docstring:
         Detect quote currency from trading symbol.
         
         Quote currency is always the last 3 characters of the symbol.
         
         Examples:
             GBPUSD -> USD (you buy GBP with USD)
             EURUSD -> USD
             USDJPY -> JPY
             EURJPY -> JPY
         
         Args:
             symbol: Trading symbol (e.g., "GBPUSD")
         
         Returns:
             Quote currency (e.g., "USD")
         
         Raises:
             ValueError: If symbol format is invalid

    ğŸ”“ get_currency_consistency()
       Docstring:
         Get all scenarios use same quote currency.
         
         In auto mode, account currency = quote currency of symbol.
         
         Args:
             scenarios: List of scenarios to validate

================================================================================
class AbstractBlackboxWorker
  Inherits from: ABC
  File: framework/workers/abstract_blackbox_worker.py:16

  Class Docstring:
    Abstract base class for all blackbox workers
    
    Workers compute indicators/signals based on bar data

  Methods (13):

    ğŸ”’ __init__()
       Docstring:
         Initialize worker.
         
         Args:
             name: Worker name/identifier
             parameters: Worker-specific parameters
             logger: ScenarioLogger instance (REQUIRED)
         
         Raises:
             ValueError: If logger is None

    ğŸ”“ get_warmup_requirements()
       Docstring:
         Get warmup requirements per timeframe.
         
         Calculated from instance parameters (e.g., self.period).
         
         Returns:
             Dict[timeframe, bars_needed]
             Example: {"M5": 20, "M15": 20}

    ğŸ”“ get_required_timeframes()
       Docstring:
         Get required timeframes for this worker instance.
         
         Calculated from instance parameters (e.g., self.timeframe).
         
         Returns:
             List of timeframe strings
             Example: ["M5"]

    ğŸ”“ get_max_computation_time_ms()
       Docstring:
         Get max computation time for this worker instance.
         
         Optional - fÃ¼r Monitoring/Timeouts.
         Default: 100ms
         
         Returns:
             Max computation time in milliseconds

    ğŸ”“ get_required_timeframes()
       Docstring:
         Get required timeframes for this worker
         
         Returns:
             List of timeframe strings (e.g., ['M1', 'M5'])

    ğŸ”“ get_warmup_requirements()
       Docstring:
         Get warmup requirements per timeframe
         
         Returns:
             Dict[timeframe, bars_needed]

    ğŸ”“ should_recompute()
       Docstring:
         Determine if worker should recompute on this tick
         
         Args:
             tick: Current tick data
             bar_updated: Whether a bar was updated/completed
         
         Returns:
             True if recomputation needed

    ğŸ”“ compute()
       Docstring:
         Compute worker output based on bar data
         
         Args:
             tick: Current tick (for metadata/timestamp)
             bar_history: Historical bars per timeframe
             current_bars: Current bars per timeframe
         
         Returns:
             WorkerResult with computed value

    ğŸ”“ get_last_result()
       Docstring:
         Get last computation result

    ğŸ”“ set_state()
       Docstring:
         Update worker state

    ğŸ”“ set_performance_logger()
       Docstring:
         Set performance logger for this worker.
         
         Called by WorkerCoordinator during initialization.
         
         Args:
             logger: PerformanceLogWorker instance

    ğŸ”“ get_worker_type()
       Docstring:
         Get worker type classification for monitoring.
         
         Override in subclass if needed.
         
         Returns:
             WorkerType enum value

    ğŸ”“ get_default_parameters()
       Docstring:
         Get default parameter values.
         
         Used by factory for validation and defaults.
         Override in subclass to provide defaults.
         
         Returns:
             Dict of default parameter values

================================================================================
class EnvelopeWorker
  Inherits from: AbstractBlackboxWorker
  File: framework/workers/core/envelope_worker.py:17

  Class Docstring:
    Envelope/Bollinger Band worker - Bar-based computation

  Methods (8):

    ğŸ”’ __init__()
       Docstring:
         Initialize Envelope worker.
         
         Parameters can be provided via:
         - parameters dict (factory-style)
         - kwargs (legacy constructor-style)
         
         Optional parameters (all have defaults):
         - period: Moving average period (default: 20)
         - deviation: Band deviation multiplier (default: 0.02)
         - timeframe: Timeframe to use (default: "M5")

    ğŸ”“ get_required_parameters()
       Docstring:
         Envelope hat KEINE required parameters - alle haben defaults

    ğŸ”“ get_optional_parameters()
       Docstring:
         Envelope hat NUR optionale Parameter mit defaults

    ğŸ”“ get_warmup_requirements()
       Docstring:
         Envelope braucht 'period' bars.
         
         Berechnet aus self.period (aus Config!)

    ğŸ”“ get_required_timeframes()
       Docstring:
         Envelope braucht nur einen Timeframe.
         
         Berechnet aus self.timeframe (aus Config!)

    ğŸ”“ get_max_computation_time_ms()
       Docstring:
         Envelope ist schnell - 50ms Timeout

    ğŸ”“ should_recompute()
       Docstring:
         Envelope recomputes when bar updated

    ğŸ”“ compute()
       Docstring:
         Envelope/Bollinger Band computation using bar close prices
         
         Args:
             tick: Current tick (for metadata only)
             bar_history: Historical bars per timeframe
             current_bars: Current bars per timeframe
         
         Returns:
             WorkerResult with envelope bands

================================================================================
class HeavyRSIWorker
  Inherits from: AbstractBlackboxWorker
  File: framework/workers/core/heavy_workers.py:18

  Class Docstring:
    RSI Worker mit kÃ¼nstlicher CPU-Last.
    Simuliert komplexe Berechnungen (z.B. ML-Model, FFT, etc.)

  Methods (9):

    ğŸ”’ __init__()
       Docstring:
         Args:
             name: Worker name
             parameters: Factory-style parameters dict
             **kwargs: Legacy constructor support
         
         Required parameters:
             - period: RSI calculation period
             - timeframe: Timeframe to use
         
         Optional parameters:
             - artificial_load_ms: CPU load duration (default: 5.0ms)

    ğŸ”“ get_required_parameters()
       Docstring:
         Heavy RSI benÃ¶tigt period und timeframe

    ğŸ”“ get_optional_parameters()
       Docstring:
         Heavy RSI hat artificial_load als optional

    ğŸ”“ get_warmup_requirements()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_required_timeframes()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_max_computation_time_ms()
       âš ï¸  NO DOCSTRING

    ğŸ”“ should_recompute()
       âš ï¸  NO DOCSTRING

    ğŸ”“ compute()
       Docstring:
         RSI computation mit kÃ¼nstlicher CPU-Last

    ğŸ”’ _simulate_heavy_computation()
       Docstring:
         Simuliert CPU-intensive Berechnungen (Matrix ops)

================================================================================
class HeavyEnvelopeWorker
  Inherits from: AbstractBlackboxWorker
  File: framework/workers/core/heavy_workers.py:135

  Class Docstring:
    Envelope Worker mit kÃ¼nstlicher CPU-Last.
    Simuliert komplexe Band-Berechnungen.

  Methods (9):

    ğŸ”’ __init__()
       Docstring:
         Args:
             name: Worker name
             parameters: Factory-style parameters dict
         
         Optional parameters (all have defaults):
             - period: MA period (default: 20)
             - deviation: Band deviation (default: 0.02)
             - timeframe: Timeframe (default: "M5")
             - artificial_load_ms: CPU load (default: 8.0ms)

    ğŸ”“ get_required_parameters()
       Docstring:
         Heavy Envelope hat keine required parameters

    ğŸ”“ get_optional_parameters()
       Docstring:
         Heavy Envelope - alle Parameter optional mit defaults

    ğŸ”“ get_warmup_requirements()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_required_timeframes()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_max_computation_time_ms()
       âš ï¸  NO DOCSTRING

    ğŸ”“ should_recompute()
       âš ï¸  NO DOCSTRING

    ğŸ”“ compute()
       Docstring:
         Envelope computation mit kÃ¼nstlicher CPU-Last

    ğŸ”’ _simulate_heavy_computation()
       Docstring:
         Simuliert FFT-like computations

================================================================================
class HeavyMACDWorker
  Inherits from: AbstractBlackboxWorker
  File: framework/workers/core/heavy_workers.py:257

  Class Docstring:
    MACD Worker mit kÃ¼nstlicher CPU-Last.
    ZusÃ¤tzlicher Worker fÃ¼r bessere Parallelisierungs-Tests.

  Methods (10):

    ğŸ”’ __init__()
       Docstring:
         Args:
             name: Worker name
             parameters: Factory-style parameters dict
         
         Optional parameters:
             - fast: Fast EMA period (default: 12)
             - slow: Slow EMA period (default: 26)
             - signal: Signal line period (default: 9)
             - timeframe: Timeframe (default: "M5")
             - artificial_load_ms: CPU load (default: 6.0ms)

    ğŸ”“ get_required_parameters()
       Docstring:
         Heavy MACD hat keine required parameters

    ğŸ”“ get_optional_parameters()
       Docstring:
         Heavy MACD - alle Parameter optional mit defaults

    ğŸ”“ get_warmup_requirements()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_required_timeframes()
       âš ï¸  NO DOCSTRING

    ğŸ”“ get_max_computation_time_ms()
       âš ï¸  NO DOCSTRING

    ğŸ”“ should_recompute()
       âš ï¸  NO DOCSTRING

    ğŸ”“ compute()
       Docstring:
         MACD computation mit kÃ¼nstlicher Last

    ğŸ”’ _ema()
       Docstring:
         Simple EMA calculation

    ğŸ”’ _simulate_heavy_computation()
       Docstring:
         Simuliert ML-Ã¤hnliche Berechnungen

================================================================================
class RSIWorker
  Inherits from: AbstractBlackboxWorker
  File: framework/workers/core/rsi_worker.py:12

  Class Docstring:
    RSI computation worker - Bar-based computation

  Methods (8):

    ğŸ”’ __init__()
       Docstring:
         Initialize RSI worker.
         
         Parameters can be provided via:
         - parameters dict (factory-style)
         - kwargs (legacy constructor-style)
         
         Required parameters:
         - period: RSI calculation period
         - timeframe: Timeframe to use

    ğŸ”“ get_required_parameters()
       Docstring:
         RSI benÃ¶tigt period und timeframe zwingend

    ğŸ”“ get_optional_parameters()
       Docstring:
         RSI hat aktuell keine optionalen Parameter

    ğŸ”“ get_warmup_requirements()
       Docstring:
         RSI braucht exakt 'period' bars.
         
         Berechnet aus self.period (aus Config!)

    ğŸ”“ get_required_timeframes()
       Docstring:
         RSI braucht nur einen Timeframe.
         
         Berechnet aus self.timeframe (aus Config!)

    ğŸ”“ get_max_computation_time_ms()
       Docstring:
         RSI ist schnell - 50ms Timeout

    ğŸ”“ should_recompute()
       Docstring:
         RSI recomputes when bar updated

    ğŸ”“ compute()
       Docstring:
         RSI computation using bar close prices

================================================================================
class WorkerCoordinator
  File: framework/workers/worker_coordinator.py:29

  Class Docstring:
    Orchestrates multiple workers and delegates decision-making to DecisionLogic.
    
    This class is the central coordination point for tick-by-tick processing.
    It manages worker execution (sequential or parallel) and collects their
    results, then passes those results to the DecisionLogic for decision-making.
    
    The Coordinator has NO knowledge of specific indicators (RSI, Envelope, etc.)
    or trading strategies - that's all delegated to Workers and DecisionLogic.

  Methods (12):

    ğŸ”’ __init__()
       Docstring:
         Initialize coordinator with injected workers and decision logic.
         
         Args:
             workers: List of worker instances (created by Factory)
             decision_logic: Decision logic instance (e.g., SimpleConsensus)
             parallel_workers: Enable parallel worker execution (None = auto-detect)
             parallel_threshold_ms: Min worker time to activate parallel (default: 1.0ms)
             scenario_name: Name of the scenario being executed
         
             Der WorkerCoordinator selbst bekommt KEINEN separaten Logger-Parameter,
             weil er bereits die DecisionLogic bekommt, die einen Logger hat.
         
             Der Coordinator nutzt einfach den Logger der DecisionLogic fÃ¼r seine Logs.
             Das macht Sinn weil:
             - Coordinator lÃ¤uft im Kontext eines Scenarios
             - DecisionLogic hat bereits den richtigen ScenarioLogger
             - Vermeidet doppelte Logger-Ãœbergabe

    ğŸ”’ _extract_worker_type()
       Docstring:
         Extract worker type from worker instance.
         
         Tries to get it from parameters or falls back to class name.
         
         Args:
             worker: Worker instance
         
         Returns:
             Worker type string (e.g., "CORE/rsi")

    ğŸ”’ _extract_decision_logic_type()
       Docstring:
         Extract decision logic type from instance.
         
         Tries to get it from config or falls back to class name.
         
         Args:
             decision_logic: Decision logic instance
         
         Returns:
             Decision logic type string (e.g., "CORE/simple_consensus")

    ğŸ”’ _validate_decision_logic_requirements()
       Docstring:
         Validate that all required worker instances are available with correct types.
         
         Validation flow:
         1. Get required worker instances from DecisionLogic (instance_name â†’ worker_type)
         2. Get configured worker_instances from config
         3. Validate:
         - All required instance names exist in config
         - All instance types match exactly (no override allowed)
         - All required instances were successfully created
         
         Raises:
             ValueError: If requirements not met

    ğŸ”’ _auto_detect_parallel_mode()
       Docstring:
         Auto-detect parallel mode based on worker count

    ğŸ”“ initialize()
       Docstring:
         Initialize coordinator and all workers

    ğŸ”“ process_tick()
       Docstring:
         Process tick through all workers and generate decision.
         
         Args:
             tick: Current tick data
             current_bars: Current bars per timeframe
             bar_history: Historical bars per timeframe
         
         Returns:
             Decision object (from DecisionLogic)

    ğŸ”’ _process_workers_sequential()
       Docstring:
         Process workers sequentially (original behavior).
         
         UNCHANGED - This method works exactly as before.

    ğŸ”’ _process_workers_parallel()
       Docstring:
         Process workers in parallel using ThreadPoolExecutor.
         
         UNCHANGED - Parallelization logic works exactly as before.
         Performance boost: Workers compute simultaneously!

    ğŸ”’ _compute_worker()
       Docstring:
         Compute worker result (thread-safe helper method).
         
         UNCHANGED - Worker computation works exactly as before.
         
         Returns:
             Tuple of (result, computation_time_ms)

    ğŸ”“ get_worker_results()
       Docstring:
         Get all current worker results.
         
         UNCHANGED - This method works exactly as before.

    ğŸ”“ cleanup()
       Docstring:
         Clean up resources.

================================================================================
class ScenarioConfigLoader
  File: scenario/config_loader.py:23

  Class Docstring:
    Loads test scenarios from JSON config files
    
    FIXED (Parameter Inheritance Bug):
    Uses deep copy to prevent config mutation across scenarios

  Methods (4):

    ğŸ”’ __init__()
       Docstring:
         Args:
             config_path: Directory containing scenario config files

    ğŸ”“ load_config()
       Docstring:
         Load scenarios from JSON config file
         
         Args:
             config_file: Config filename (e.g., "eurusd_3_windows.json")
         
         Returns:
             List of SingleScenario objects

    ğŸ”’ _deep_merge_strategy_configs()
       Docstring:
         Deep merge strategy configs with FULL cascading support.
         
         FIXED: Now handles decision_logic_config properly!

    ğŸ”’ _validate_scenario_dates()
       Docstring:
         Validate scenario date range and log execution mode.
         
         NO AUTO-FIX! Just validation and mode logging.
         
         Cases:
         A) max_ticks set + valid dates â†’ INFO (tick-limited mode)
         B) max_ticks null + valid dates â†’ INFO (timespan mode)
         C) max_ticks null + invalid dates â†’ ERROR (critical config error)
         D) max_ticks set + invalid dates â†’ ERROR (invalid config)
         
         Args:
             scenario_data: Scenario dict (read-only)
         
         Raises:
             ValueError: If dates are invalid

================================================================================
class MarketAnalyzer
  File: scenario/market_analyzer.py:41

  Class Docstring:
    Analyzes market data for scenario generation.
    
    Performs on-the-fly analysis of bar data to classify time periods
    by volatility regime, tick density, and trading session.
    
    Filters out synthetic-only periods (weekends, gaps) automatically.

  Methods (16):

    ğŸ”’ __init__()
       Docstring:
         Initialize market analyzer.
         
         Args:
             data_dir: Path to processed data directory
             config_path: Path to analysis config JSON (optional)

    ğŸ”’ _load_analysis_config()
       Docstring:
         Load configuration from JSON file.
         
         Args:
             config_path: Path to config file
         
         Returns:
             GeneratorConfig instance

    ğŸ”“ get_config()
       Docstring:
         Get current configuration.

    ğŸ”’ _load_broker_configs()
       Docstring:
         Load broker configurations and build symbol specification cache.
         
         Loads all broker configs from paths in analysis config.
         Builds cache mapping symbol -> SymbolSpecification for pip calculation.

    ğŸ”’ _calculate_pips_per_day()
       Docstring:
         Calculate average pips per day from ATR.
         
         Args:
             symbol: Trading symbol
             avg_absolute_atr: Average absolute ATR value
         
         Returns:
             Pips per day or None if symbol spec not found

    ğŸ”“ analyze_symbol()
       Docstring:
         Perform complete market analysis for a symbol.
         
         Automatically filters out periods without real data (weekends, gaps).
         
         Args:
             symbol: Trading symbol (e.g., 'EURUSD')
             timeframe: Timeframe to analyze (default from config)
         
         Returns:
             SymbolAnalysis with all metrics and period classifications

    ğŸ”’ _prepare_dataframe()
       Docstring:
         Prepare dataframe for analysis.
         
         Args:
             df: Raw bar dataframe
         
         Returns:
             Prepared dataframe with UTC timestamps

    ğŸ”’ _calculate_atr()
       Docstring:
         Calculate Average True Range for bars.
         
         Args:
             df: Bar dataframe with OHLC
         
         Returns:
             Dataframe with 'atr' column added

    ğŸ”’ _analyze_periods()
       Docstring:
         Analyze data grouped by time periods.
         
         Filters out periods without real data (synthetic-only from weekends/gaps).
         
         Args:
             df: Prepared bar dataframe
             symbol: Trading symbol
         
         Returns:
             List of PeriodAnalysis objects (only valid trading periods)

    ğŸ”’ _get_percentile()
       Docstring:
         Get percentile rank of a value.
         
         Args:
             value: Value to rank
             all_values: All values for comparison
         
         Returns:
             Percentile (0-100)

    ğŸ”’ _classify_regime()
       Docstring:
         Classify volatility regime based on ratio to average ATR.
         
         Uses relative thresholds for consistent classification across symbols.
         
         Returns:
             VolatilityRegime enum

    ğŸ”’ _calculate_regime_distribution()
       Docstring:
         Calculate distribution of volatility regimes.
         
         Args:
             periods: List of period analyses
         
         Returns:
             Dict mapping regime to count

    ğŸ”’ _calculate_session_summaries()
       Docstring:
         Calculate summary statistics per trading session.
         
         Args:
             periods: List of period analyses
         
         Returns:
             Dict mapping session to summary

    ğŸ”“ list_symbols()
       Docstring:
         List available symbols in bar index.
         
         Returns:
             Sorted list of symbol names

    ğŸ”“ get_available_timeframes()
       Docstring:
         Get available timeframes for a symbol.
         
         Args:
             symbol: Trading symbol
         
         Returns:
             List of timeframe strings

    ğŸ”“ get_index_entry()
       Docstring:
         Get bar index entry for symbol/timeframe.
         
         Args:
             symbol: Trading symbol
             timeframe: Timeframe string
         
         Returns:
             Index entry dict or None

================================================================================
class ScenarioGenerator
  File: scenario/scenario_generator.py:40

  Class Docstring:
    Generates scenario configurations from market analysis.
    
    Uses MarketAnalyzer results to select optimal time periods
    based on volatility, activity, and data quality.

  Methods (12):

    ğŸ”’ __init__()
       Docstring:
         Initialize scenario generator.
         
         Args:
             data_dir: Path to processed data directory
             config_path: Path to generator config JSON

    ğŸ”“ generate()
       Docstring:
         Generate scenario candidates.
         
         Args:
             symbols: List of symbols to generate for
             strategy: Generation strategy
             count: Number of scenarios
             block_hours: Block size for blocks strategy
             session_filter: Filter by session name
             start_filter: Start date filter
             end_filter: End date filter
             max_ticks: Max ticks per scenario
         
         Returns:
             GenerationResult with selected scenarios

    ğŸ”’ _filter_periods()
       Docstring:
         Filter periods by session and time range.
         
         Args:
             periods: All periods
             session_filter: Session name filter
             start_filter: Start datetime
             end_filter: End datetime
         
         Returns:
             Filtered periods

    ğŸ”’ _generate_balanced()
       Docstring:
         Generate balanced scenarios across volatility regimes.
         
         Selects equal number from each regime for comprehensive testing.
         
         Args:
             symbol: Trading symbol
             periods: Available periods
             count: Total scenarios to generate
             max_ticks: Max ticks per scenario
         
         Returns:
             List of scenario candidates

    ğŸ”’ _generate_blocks_from_coverage()
       Docstring:
         Generate chronological blocks based on coverage report.
         
         Uses gap analysis to create blocks only within continuous data regions.
         Gaps of type moderate/large/weekend interrupt blocks.
         
         Args:
             symbol: Trading symbol
             block_hours: Maximum hours per block
             count_max: Optional limit on number of blocks (None = all)
             sessions_filter: Optional list of session names to include
         
         Returns:
             List of scenario candidates with max_ticks=None

    ğŸ”’ _extract_continuous_regions()
       Docstring:
         Extract continuous data regions from coverage report.
         
         Regions are split by moderate, large, and weekend gaps.
         
         Args:
             coverage_report: Analyzed coverage report
         
         Returns:
             List of dicts with 'start' and 'end' datetime keys

    ğŸ”’ _extract_session_windows()
       Docstring:
         Extract time windows within allowed trading sessions.
         
         Iterates hour by hour and groups consecutive hours in allowed sessions.
         
         Args:
             start: Region start time
             end: Region end time
             allowed_sessions: Set of TradingSession enums to include
         
         Returns:
             List of dicts with 'start' and 'end' datetime keys

    ğŸ”’ _generate_stress()
       Docstring:
         Generate stress test scenarios.
         
         Selects periods with highest volatility AND tick density.
         
         Args:
             symbol: Trading symbol
             periods: Available periods
             count: Number of scenarios
             max_ticks: Max ticks per scenario
         
         Returns:
             List of stress test candidates

    ğŸ”’ _period_to_candidate()
       Docstring:
         Convert period analysis to scenario candidate.
         
         Args:
             symbol: Trading symbol
             period: Period analysis
             max_ticks: Max ticks override
         
         Returns:
             ScenarioCandidate

    ğŸ”’ _build_result()
       Docstring:
         Build generation result from scenarios.
         
         Args:
             symbol: Trading symbol
             strategy: Strategy used
             scenarios: Generated scenarios
         
         Returns:
             GenerationResult

    ğŸ”“ save_config()
       Docstring:
         Save generation result as scenario set config.
         
         Args:
             result: Generation result
             filename: Output filename
         
         Returns:
             Path to saved config file

    ğŸ”’ _get_default_template()
       Docstring:
         Get default template when file not found.
         
         Returns:
             Default config dictionary